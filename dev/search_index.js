var documenterSearchIndex = {"docs":
[{"location":"man/setrep/#Set-representations-1","page":"Set representations","title":"Set representations","text":"","category":"section"},{"location":"man/setrep/#Reach-sets-1","page":"Set representations","title":"Reach-sets","text":"","category":"section"},{"location":"man/setrep/#Flowpipes-1","page":"Set representations","title":"Flowpipes","text":"","category":"section"},{"location":"references/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"This page includes the original references for each algorithm included in this library. If you use ReachabilityAnalysis.jl for your own work, do consider citing the appropriate original reference.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"[G05] Girard, A. (2005, March). Reachability of uncertain linear systems using       zonotopes.       In International Workshop on Hybrid Systems: Computation and Control (pp. 291-305).       Springer, Berlin, Heidelberg.\n[GLM06] Girard, A., Le Guernic, C., & Maler, O. (2006, March).        Efficient computation of reachable sets of linear time-invariant systems        with inputs.        In International Workshop on Hybrid Systems: Computation and Control (pp. 257-271).        Springer, Berlin, Heidelberg.","category":"page"},{"location":"lib/algorithms/TMJets/#","page":"TMJets","title":"TMJets","text":"TMJets","category":"page"},{"location":"lib/algorithms/TMJets/#ReachabilityAnalysis.TMJets","page":"TMJets","title":"ReachabilityAnalysis.TMJets","text":"TMJets{N} <: AbstractContinuousPost\n\nValidated integration with Taylor models, based on the algorithm implemented by Luis Benet and David Sanders in TalorModels.jl.\n\nFields\n\nmax_steps – (optional, default: 1000) maximum number of steps in the                validated integration x = f(x)\nabs_tol   – (optional, default: 1e-15) absolute tolerance\norderT    – (optional, default: 8) order of the Taylor model in time\norderQ    – (optional, default: 2) order of the Taylor models for jet                transport variales\n\n\n\n\n\n","category":"type"},{"location":"man/linear_high_dim/#Exploiting-structure-1","page":"Exploiting structure","title":"Exploiting structure","text":"","category":"section"},{"location":"man/linear_high_dim/#","page":"Exploiting structure","title":"Exploiting structure","text":"In this section we consider reachability analysis for subsets of variables of a given linear system. Let","category":"page"},{"location":"man/linear_high_dim/#","page":"Exploiting structure","title":"Exploiting structure","text":"x(t) = Ax(t) + v(t)","category":"page"},{"location":"man/linear_high_dim/#","page":"Exploiting structure","title":"Exploiting structure","text":"a = 1\nb = 2\na + b","category":"page"},{"location":"lib/solutions/#","page":"Solutions","title":"Solutions","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/solutions/#Solutions-1","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"lib/solutions/#Abstract-interface-1","page":"Solutions","title":"Abstract interface","text":"","category":"section"},{"location":"lib/solutions/#","page":"Solutions","title":"Solutions","text":"ReachabilityAnalysis.AbstractSolution","category":"page"},{"location":"lib/solutions/#ReachabilityAnalysis.AbstractSolution","page":"Solutions","title":"ReachabilityAnalysis.AbstractSolution","text":"AbstractSolution\n\nAbstract supertype of all solution types of a rechability problem.\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#Solution-of-a-reachability-problem-1","page":"Solutions","title":"Solution of a reachability problem","text":"","category":"section"},{"location":"lib/solutions/#","page":"Solutions","title":"Solutions","text":"ReachabilityAnalysis.ReachSolution","category":"page"},{"location":"lib/solutions/#ReachabilityAnalysis.ReachSolution","page":"Solutions","title":"ReachabilityAnalysis.ReachSolution","text":"ReachSolution{FT<:AbstractFlowpipe, ST<:AbstractPost} <: AbstractSolution\n\nType that wraps the solution of a reachability problem as a sequence of lazy sets, and a dictionary of options.\n\nFields\n\nXk       – the list of AbstractReachSets\noptions  – the dictionary of options\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#","page":"Solutions","title":"Solutions","text":"TODO: document other methods in solutions.jl.","category":"page"},{"location":"man/applications/epidemic/#","page":"Epidemic disease","title":"Epidemic disease","text":"https://doktormike.gitlab.io/post/covid-19/s","category":"page"},{"location":"about/#About-1","page":"About","title":"About","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"page"},{"location":"about/#Contributing-1","page":"About","title":"Contributing","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"If you like this package, consider contributing! We welcome bug reports, examples that can be added to the documentation, or new feature proposals.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Below we list some conventions that we follow when contributing to this package. For specific guidelines on documentation see the JuliaReach Developer's Documentation.","category":"page"},{"location":"about/#Branches-1","page":"About","title":"Branches","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"Each pull request (PR) should be pushed in a new branch with the name of the author followed by a descriptive name, e.g. mforets/my_feature. If the branch is associated to a previous discussion in an issue, we use the name of the issue for easier lookup, e.g. mforets/7.","category":"page"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)-1","page":"About","title":"Unit testing and continuous integration (CI)","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This project is synchronized with Travis CI, such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to understand and fix the failing tests if they exist. We support Julia v1.0 and develop in the latest stable release. For experimentation we also build on the nightly branch.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"To run the unit tests locally, you should do:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes test/runtests.jl","category":"page"},{"location":"about/#Contributing-to-the-documentation-1","page":"About","title":"Contributing to the documentation","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This documentation is written in Markdown, and it relies on Documenter.jl to produce the HTML layout. To build the documentation, run make.jl:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"man/linear/#Linear-ordinary-differential-equations-1","page":"Linear ODEs","title":"Linear ordinary differential equations","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In this section we show how to solve initial value problems with sets of initial conditions. First we consider the simple scalar equation x(t) = -x(t), where x(0) may be any point in a given initial interval mathcalX_0. Then we consider the spring-mass system, a second order linear ODE studied in introductory physics courses. For that system we show an example of how to compute and project the flowpipe, and then plot the variables of interest.","category":"page"},{"location":"man/linear/#Example-1","page":"Linear ODEs","title":"Example","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Our first example is an initial-value problem for the one-dimensional differential equation","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"x(t) = -x(t)qquad 0  t  T = 40","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"with initial condition x(0)  045 055.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"We can compute the flowpipe using solve:","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"using ReachabilityAnalysis, Plots\n\n# define the initial-value problem\nprob = @ivp(x' = -x, x(0) ∈ 0.45 .. 0.55)\n\n# solve it\nsol = solve(prob, T=4.0)\n\n# plot the solution, where the index 0 corresponds to the \"time\" variable\nplot(sol, vars=(0, 1), label=\"Flowpipe\", xlab=\"t\", ylab=\"x(t)\", linewidth=0.3)","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In practice, analytic solutons of ODEs are unknown. However, in this simple case we know that for an initial point x_0 in mathbbR, the solution is x(t) = x_0 e^-t. We can plot some trajectories in the same plot as the flowpipe, to see that the trajectories are indeed inside the flowpipe, as expected.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"f(t, x0) = x0 * exp(-t)\n\nplot!(t -> f(t, 0.45), xlims=(0, 4), label=\"Analytic sol., x(0) = 0.45\", color=\"red\")\nplot!(t -> f(t, 0.55), xlims=(0, 4), label=\"Analytic sol., x(0) = 0.55\", color=\"red\")","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"This example illustrates that the solution process mainly consists of three steps:","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"(1) Formulating the mathematical problem, in the form of an initial-value problem     with possibly uncertain initial states or inputs.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"(2) Solving the problem, either with the default algorithm or specifying the algorithm     and some of its options.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"(3) Extracting the results, either to visualize with a plot, or to project onto     the relevant variables for further study.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Below we give some further details of this solution step for the simple scalar equation presented above.","category":"page"},{"location":"man/linear/#Problem-formulation-1","page":"Linear ODEs","title":"Problem formulation","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Solution process","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"To illustrate the solution process, we consider a spring-mass system illustrated in the following figure.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"The mass is m and the elastic constant of the spring is k.","category":"page"},{"location":"man/linear/#Solving-the-initial-value-problem-1","page":"Linear ODEs","title":"Solving the initial-value problem","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In this case the system is not given as a set of first-order ODEs, so we will make that transformation as a first step.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Transforming higher-order into a first-order system.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Formulating the mathematical problem involves writing the system as a first-order","category":"page"},{"location":"man/linear/#Analyzing-the-solution-1","page":"Linear ODEs","title":"Analyzing the solution","text":"","category":"section"},{"location":"man/linear/#Spring-mass-system-1","page":"Linear ODEs","title":"Spring-mass system","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In the following example we consider a spring-mass system which is a linear ODE with two-degrees of freedom.","category":"page"},{"location":"man/nonlinear/#Nonlinear-ordinary-differential-equations-1","page":"Nonlinear ODEs","title":"Nonlinear ordinary differential equations","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"In this section we illustrate the flowpipe computation for a nonlinear system.","category":"page"},{"location":"man/nonlinear/#Model-description-1","page":"Nonlinear ODEs","title":"Model description","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Our running example is the Lotka-Volterra model. The 2-dimensional Lotka-Volterra system depicts the populations change of a class of predators and a class of preys. The growth rate of preys’ population x over time is given by","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"dotx = xcdot (alpha - beta cdot y)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"wherein  alpha beta are constant parameters and y is the population of predators.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"It gives that the number of preys grows exponentially without predation.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"The population growth of predators is governed by the differential equation","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"doty = -ycdot (gamma - deltacdot x)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"wherein  gamma delta are constant parameters.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We set those parameters as  alpha = 15   beta = 1   gamma = 3  and  delta = 1.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"using ReachabilityAnalysis\n\n@taylorize function lotka_volterra!(du, u, p, t)\n    local α, β, γ, δ = 1.5, 1.0, 3.0, 1.0\n    du[1] = u[1] * (α - β*u[2])\n    du[2] = -u[2] * (γ - δ*u[1])\n    return du\nend","category":"page"},{"location":"man/nonlinear/#Reachability-settings-1","page":"Nonlinear ODEs","title":"Reachability settings","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"The reachability settings are taken from this resource.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We consider the initial set  xin 4852 y in 1822.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"X₀ = Hyperrectangle(low=[4.8, 1.8], high=[5.2, 2.2])\n\nprob = @ivp(x' = lotka_volterra!(x), dim: 2, x(0) ∈ X₀)","category":"page"},{"location":"man/nonlinear/#Results-1","page":"Nonlinear ODEs","title":"Results","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We compute the flowpipe using the TMJets algorithm for the time horizon 05:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"sol = solve(prob, T=5.0)\n\nsetrep(sol)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We can change to the zonotopic overapproximation of the flowpipe using the overapproximate function:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"sol = overapproximate(sol, Zonotope)\n\nsetrep(sol)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Finally we plot the solution in phase-space:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"using Plots\n\nplot(sol, vars=(1, 2), xlab=\"x\", ylab=\"y\", lw=0.2, color=:lightblue, lab=\"Flowpipe\")\nplot!(X₀, color=:orange, lab=\"Xo\")","category":"page"},{"location":"lib/algorithms/GLGM06/#","page":"GLGM06","title":"GLGM06","text":"GLGM06","category":"page"},{"location":"lib/algorithms/GLGM06/#ReachabilityAnalysis.GLGM06","page":"GLGM06","title":"ReachabilityAnalysis.GLGM06","text":"GLGM06{N, AM} <: AbstractContinuousPost\n\nImplementation of Girard - Le Guernic - Maler algorithm for reachability of uncertain linear systems using zonotopes.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default _DEFAULT_APPROX_MODEL_GLGM06) approximation model                   for the discretization of the ODE; see Notes below\nmax_order    – (optional, default: 10) maximum zonotope order\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\n\nReferences\n\nSee [xxx] and [yyy]\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/LGG09/#","page":"LGG09","title":"LGG09","text":"LGG09","category":"page"},{"location":"lib/algorithms/LGG09/#ReachabilityAnalysis.LGG09","page":"LGG09","title":"ReachabilityAnalysis.LGG09","text":"LGG09{N, AM} <: AbstractContinuousPost\n\nImplementation of Girard - Le Guernic algorithm for reachability analysis using support functions.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional) approximation model for the discretization of the                   ODE; see Notes below for details\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\n\nReferences\n\nSee [1] and [2].\n\n[1] Girard, A. (2005, March). Reachability of uncertain linear systems using zonotopes.     In International Workshop on Hybrid Systems: Computation and Control (pp. 291-305).     Springer, Berlin, Heidelberg.     Link\n\n[2] Girard, A., Le Guernic, C., & Maler, O. (2006, March).     Efficient computation of reachable sets of linear time-invariant systems with inputs.     In International Workshop on Hybrid Systems: Computation and Control (pp. 257-271).     Springer, Berlin, Heidelberg.     Link.\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/BOX/#","page":"BOX","title":"BOX","text":"BOX","category":"page"},{"location":"lib/algorithms/BOX/#ReachabilityAnalysis.BOX","page":"BOX","title":"ReachabilityAnalysis.BOX","text":"BOX{N, AM} <: AbstractContinuousPost\n\nImplementation of an integrator for linear systems usng box approximations.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional) approximation model for the discretization of the                   continuous ODE; see the Notes below for available options\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\n\nThe default approximation model used in this algorithm is:\n\nForward(sih=:concrete, exp=:base, phi2=:base, setops=:lazy)\n\nThis algorithm overapproximates the discrete sequence X_k+1 = ΦX_k  V_k by computing a tight hyperrectangular over-approximation of X_k+1 at each step k  mathbbN.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/flowpipes/#Flowpipes-1","page":"Flowpipes","title":"Flowpipes","text":"","category":"section"},{"location":"lib/flowpipes/#Abstract-interface-1","page":"Flowpipes","title":"Abstract interface","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"AbstractFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.AbstractFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.AbstractFlowpipe","text":"AbstractFlowpipe\n\nAbstract type representing a flowpipe.\n\nNotes\n\nA flowpipe is the set union of an array of reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"The following functions are available at the interface level.","category":"page"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"basetype(::Type{<:AbstractFlowpipe})\nLazySets.ρ(::AbstractVector, ::AbstractFlowpipe)\nLazySets.σ(::AbstractVector, ::AbstractFlowpipe)\nLazySets.dim(::AbstractFlowpipe)\nset(::AbstractFlowpipe, ::Integer)\ntstart(::AbstractFlowpipe)\ntend(::AbstractFlowpipe)\ntspan(::AbstractFlowpipe)","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.basetype-Tuple{Type{#s28} where #s28<:ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.basetype","text":"basetype(T::Type{<:AbstractFlowpipe})\n\nReturn the base type of the given flowpipe type (i.e., without type parameters).\n\nInput\n\nT – flowpipe type, used for dispatch\n\nOutput\n\nThe base type of T.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.ρ-Tuple{AbstractArray{T,1} where T,ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.ρ","text":"LazySets.ρ(d::AbstractVector, fp::AbstractFlowpipe)\n\nInput\n\nd  – direction\nfp – flowpipe\n\nOutput\n\nThe support function of the flowpipe along the given direction d.\n\nNotes\n\nIn this fallback implementation, the flowpipe behaves like the union of the reach-sets, i.e. the implementation is analogue to that of a LazySet.UnionSetArray.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.σ-Tuple{AbstractArray{T,1} where T,ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.σ","text":"LazySets.σ(d::AbstractVector, fp::AbstractFlowpipe)\n\nInput\n\nd  – direction\nfp – flowpipe\n\nOutput\n\nThe support vector of the flowpipe along the given direction d.\n\nNotes\n\nIn this fallback implementation, the flowpipe behaves like the union of the reach-sets, i.e. the implementation is analogue to that of a LazySet.UnionSetArray.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.dim-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.dim","text":"LazySets.dim(fp::AbstractFlowpipe)\n\nInput\n\nfp – flowpipe\n\nOutput\n\nAn integer representing the ambien dimension of the flowpipe.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.set-Tuple{ReachabilityAnalysis.AbstractFlowpipe,Integer}","page":"Flowpipes","title":"ReachabilityAnalysis.set","text":"set(fp::AbstractFlowpipe, ind::Integer)\n\nReturn the geometric set represented by this flowpipe at the given index.\n\nInput\n\nfp  – flowpipe\nind – index (from 1 to length(flowpipe))\n\nOutput\n\nThe set wrapped by the flowpipe at the given index.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tstart-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tstart","text":"tstart(fp::AbstractFlowpipe)\n\nReturn the initial time of this flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nA float representing the initial time of the given flowpipe. The fallback is computed by taking the initial time of the first reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tend-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tend","text":"tend(fp::AbstractFlowpipe)\n\nReturn the final time of this flowpipe.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the initial time of the given flowpipe. The fallback is computed by taking the final time of the last reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tspan-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tspan","text":"tspan(fp::AbstractFlowpipe)\n\nReturn time span of this flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nThe interval representing the time span of the given flowpipe. The fallback is computed as (tstart(fp), tend(fp)), see tstart(::AbstractFlowpipe) and tend(::AbstractFlowpipe) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#Flowpipe-1","page":"Flowpipes","title":"Flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"Flowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.Flowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.Flowpipe","text":"Flowpipe{N, RT<:AbstractReachSet{N}} <: AbstractFlowpipe\n\nType that wraps a flowpipe.\n\nFields\n\nXk  – set\next – extension dictionary; field used by extensions\n\nNotes\n\nThe dimension of the flowpipe corresponds to the dimension of the underlying reach-sets; in this type, it is is assumed that the dimension is the same for the different reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"The following methods are available.","category":"page"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"shift","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.shift","page":"Flowpipes","title":"ReachabilityAnalysis.shift","text":"shift(R::AbstractReachSet, t0::Number)\n\nPerform a time-shift of the given reach-set.\n\nInput\n\nR  – reach-set\nt0 – number that corresponds to the time-shift\n\nOutput\n\nA new reach-set of the same type of R such that its time-span has been shifted by t0.\n\n\n\n\n\nshift(fp::Flowpipe{N, ReachSet{N, ST}}, t0::Number) where {N, ST}\n\nReturn the time-shifted flowpipe by the given number.\n\nInput\n\nfp – flowpipe\nt0 – time shift\n\nOutput\n\nA new flowpipe such that the time-span of each constituent reach-set has been shifted by t0.\n\nNotes\n\nSee also Shift for the lazy counterpart.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#Hybrid-flowpipe-1","page":"Flowpipes","title":"Hybrid flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"HybridFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.HybridFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.HybridFlowpipe","text":"HybridFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of the same type, such that they are contiguous in time.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\nThis type assumes that the flowpipes are contiguous in time. This means that the final time the i-th flowpipe matches the start time of the i+1-th flowpipe.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Mixed-flowpipe-1","page":"Flowpipes","title":"Mixed flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"MixedFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.MixedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.MixedFlowpipe","text":"MixedFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of the same time, such that they are not necessarily contiguous in time.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\nThis type does not assume that the flowpipes are contiguous in time.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Shifted-flowpipe-1","page":"Flowpipes","title":"Shifted flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"ShiftedFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.ShiftedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.ShiftedFlowpipe","text":"ShiftedFlowpipe{FT<:AbstractFlowpipe, NT<:Number} <: AbstractFlowpipe\n\nType that lazily represents a flowpipe that has been shifted in time.\n\nFields\n\nF  – original flowpipe\nt0 – time shift\n\nNotes\n\nThis type can wrap any concrete subtype of AbstractFlowpipe, and the extra field t0 is such that the time spans of each reach-set in F are shifted by the amount t0 (which should be a subtype of Number).\n\nA convenience constructor alias Shift is given.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Partitioned-flowpipe-1","page":"Flowpipes","title":"Partitioned flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"PartitionedFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.PartitionedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.PartitionedFlowpipe","text":"PartitionedFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of possibly different types.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\n\n\n\n\n","category":"type"},{"location":"man/parametric/#Parametric-reachability-1","page":"Parametric reachability","title":"Parametric reachability","text":"","category":"section"},{"location":"man/parametric/#Theory-1","page":"Parametric reachability","title":"Theory","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"Parametric reachability consist of . . . ","category":"page"},{"location":"man/parametric/#Example-1","page":"Parametric reachability","title":"Example","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"We reconsider the example from Section (REF?), but we add an uncertain parameter α that accounts for the variation in the ...","category":"page"},{"location":"man/parametric/#Spring-mass-system-1","page":"Parametric reachability","title":"Spring-mass system","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"Here we consider variations in the constant k and perform reachability . . . .","category":"page"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"In this section we present two problems related to thermal conduction. The first problem, Heat flow PDE, is a model representing the heat xyz. The second model, Hybrid thermostat model, is","category":"page"},{"location":"man/applications/thermal_conduction/#Heat-flow-PDE-1","page":"-","title":"Heat flow PDE","text":"","category":"section"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"ver uno de los SLICOT benchmarks\nver tambien un paper de Zhi Han","category":"page"},{"location":"man/applications/thermal_conduction/#Hybrid-thermostat-model-1","page":"-","title":"Hybrid thermostat model","text":"","category":"section"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"The system is modeled as a two-mode hybrid automaton.","category":"page"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"este ya lo tenemos\nver la referencia","category":"page"},{"location":"introduction/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"In simple terms, reachability analysis is concerned with studying the sets of states that a system can reach, starting from a set of initial states and under the influence of a set of input trajectories and parameter values. More technically, we define the reachable set at a given time point delta in mathbbR, also known as the reach-set for the ODE","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"x(t) = f(x(t) u(t) p(t) t)","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"as given by","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"mathcalR(δ) = left x(δ) = int_0^δ f(x(t) u(t) p(t) t) dt x(0)  X_0 u(t)  mathcalU p(t)  mathcalP right","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Here X_0 denotes the set of initial states, mathcalU denotes the input set, and mathcalP denotes the parameter values. For practical problems, the set mathcalR(δ) cannot be obtained exactly, and reachability methods aim at computing suitable over-approximations (or under-approximations) of it.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"We define the reachable set associated to a time interval 0 δ, also known as the flowpipe, as","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"mathcalF(0 δ) = _t in 0 δ mathcalR(t)","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Reachability methods are used to compute rigorous approximations of the flowpipe for continuous or hybrid systems, in bounded time or unbounded time horizon. Here we use the term rigorous in the formal, or mathematical sense, that no solution \"escapes\" the flowpipe, for any trajectory that satisfies the constraints (initial states, inputs, and noise).","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"On the other hand, the amount of computation required depends heavily on the particular problem statement. One notable example is safety verification, which simply stated requires to prove that the flowpipe does not intersect a region of \"bad states\". In this setting, one can often reason about the flowpipe lazily, i.e. without actually computing it in full.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Up to now we have discussed about the continuous case only, but there is a rich literature in hybrid systems reachability; hybrid here means those dynamical systems which are given by one or more continuous-time dynamics (often, systems of ODEs in each mode or location) coupled with discrete transitions between continuous modes. In our context it is standard to model these systems using the terminology of hybrid automata, and we also model hybrid systems with such framework in this library. The concept of reach-set, flowpipe and safety verification are naturally extended to hybrid automata, although there is the additional complication that the flowpipe must include the behaviors for all possible transitions between discrete modes that are compatible with the dynamics.","category":"page"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/reachsets/#Reach-sets-1","page":"Reach-sets","title":"Reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#Abstract-interface-1","page":"Reach-sets","title":"Abstract interface","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"AbstractReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractReachSet","text":"AbstractReachSet{N}\n\nAbstract type for all reach-sets types.\n\nNotes\n\nA reach-set is a set representation X associated to a given time span Δt.\n\nIn its simplest form, we represent reach-sets with a struct that wraps the tuple (X, Δt), where X corresponds to a geometric set, eg. a polytope, and Δt is the interval with the time span associated to this reach-set.\n\nThis type is parametric in N. The parameter N represents for the type of numerical coefficient used in the representation (typically, N = Float64).\n\nAlthough concrete subtypes of AbstractReachSet may represent the set X in different ways, or carry additional information as an extra type field, they should all implement the AbstractReachSet interface to enable shared functionality for reach-set types. In particular, each concrete subtype should implement the following methods:\n\nset    – return the geometric set\nsetrep – return the type of the set representation\ntspan  – return the time interval span\ntstart – return the initial time\ntend   – return the final time\ndim    – return ambient dimension of the reach-set\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"The functions are available at the interface level.","category":"page"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"basetype(::Type{<:AbstractReachSet})\nset(::AbstractReachSet)\nsetrep(::AbstractReachSet)\ntspan(::AbstractReachSet)\ntstart(::AbstractReachSet)\ntend(::AbstractReachSet)\ndim(::AbstractReachSet)\ncopy(::AbstractReachSet)\nshift(::AbstractReachSet)","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.basetype-Tuple{Type{#s28} where #s28<:ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.basetype","text":"basetype(T::Type{<:AbstractReachSet})\n\nReturn the base type of the given reach-set type (i.e., without type parameters).\n\nInput\n\nT – reach-set type, used for dispatch\n\nOutput\n\nThe base type of T.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.set-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.set","text":"set(R::AbstractReachSet)\n\nReturn the geometric set represented by this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe set wrapped by the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.setrep-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.setrep","text":"setrep(R::AbstractReachSet)\n\nReturn the type of the set representation of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nType of the set representation of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tspan-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tspan","text":"tspan(R::AbstractReachSet)\n\nReturn time span of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe interval representing the time span of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tstart-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tstart","text":"tstart(R::AbstractReachSet)\n\nReturn the initial time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the initial time of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tend-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tend","text":"tend(R::AbstractReachSet)\n\nReturn the final time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the final time of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#LazySets.dim-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"LazySets.dim","text":"dim(R::AbstractReachSet)\n\nReturn the ambient dimension of the reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nAn integer corresponding to the ambient dimension of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#Base.copy-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"Base.copy","text":"copy(R::AbstractReachSet)\n\nReturn a copy of the given reach-set.\n\nInput\n\nR  – reach-set\n\nOutput\n\nA new reach-set of the sam type and the same field values as R.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.shift-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.shift","text":"shift(fp::Flowpipe{N, ReachSet{N, ST}}, t0::Number) where {N, ST}\n\nReturn the time-shifted flowpipe by the given number.\n\nInput\n\nfp – flowpipe\nt0 – time shift\n\nOutput\n\nA new flowpipe such that the time-span of each constituent reach-set has been shifted by t0.\n\nNotes\n\nSee also Shift for the lazy counterpart.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"AbstractLazyReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractLazyReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractLazyReachSet","text":"AbstractLazyReachSet{N} <: AbstractReachSet{N}\n\nAbstract type for all reach-set types that use a LazySet for the underlying set representation.\n\nNotes\n\nAn AbstractLazyReachSet is the interface for reach-sets such that the geometric set is represented by any subtype of LazySet.\n\nThis types implements the LazySets interface, namely support function (ρ), support vector (σ) and ambient dimension (dim) functions. Hence, these functions directly apply to concrete subtypes of an AbstractLazyReachSet. The set wrapped by this type is obtained through set(R).\n\nThe following functions should be implemented by any concrete subtype:\n\nreconstruct – create a new instance of the given reach-set with a different                  set representation but sharing the other fields, i.e. the same                  time span (and the same for other fields, if applicable)\n\nIn addition to the functions inherited from AbstractReachSet, the following are available:\n\nproject  – projection of a reach-set\nshift    – time-shift of a reach-set\nvars_idx – tuple of integers associated to the variables of the given reach-set\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Reachable-set-1","page":"Reach-sets","title":"Reachable set","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"ReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.ReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.ReachSet","text":"ReachSet{N, ST<:LazySet{N}} <: AbstractLazyReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation.\n\nFields\n\nX  – set\nΔt – time interval\n\nNotes\n\nA ReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype LazySet. For efficiency reasons, ST should be concretely typed.\n\nBy assumption the coordinates in this reach-set are associated to the integers 1, …, n. The function vars_idx returns such tuple.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Sparse-reachable-set-1","page":"Reach-sets","title":"Sparse reachable set","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"SparseReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.SparseReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.SparseReachSet","text":"SparseReachSet{N, ST<:LazySet{N}, D} <: AbstractReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation, together with a tuple of variables associated to this reach-set.\n\nFields\n\nX        – set\nΔt       – time interval\nvars_idx – tuple of variable indices represented by the set X\n\nNotes\n\nA SparseReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype of LazySet (ideally, concrete). Moreover, this type also stores information about the variables (also named coordinates, or by abuse of notation, dimensions) corresponding to the set X.\n\nFor instance in the ambient space n=5, one may have a SparseReachSet whose variables tuple is vars = (4, 5, 6), i.e. representing a three-dimensional projection of the full-dimensional reach-set. In consequence, the dimension of X doesn't match the length of vars, in general\n\nIn this type, the parameter N represents the numerical type of the LazySet (typically, Float64), the type ST represents the set representation used, and D denotes the dimension of this sparse reach set. Note that, in contrast to ReachSet, for SparseReachSet the number of dimensions is part of the type information.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Projections-1","page":"Reach-sets","title":"Projections","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"project","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.project","page":"Reach-sets","title":"ReachabilityAnalysis.project","text":"project(R::Union{ReachSet, SparseReachSet}, vars::NTuple{D, Int};\n        [check_vars]::Bool=true) where {D}\n\nProjects a reach-set onto the subspace spanned by the given variables.\n\nInput\n\nR          – reach-set\nvars       – tuple of variables for the projection\ncheck_vars – (optional, default: true) if true, check that the given variable                 indices vars are a subset of the variables of R\n\nOutput\n\nA SparseReachSet whose variable indices are given by vars.\n\nThe type of the new reach-set depends on the type of the reach-set R:\n\nIf R contains a hyperrectangular set, the output is a hyperrectangle.\nIf R contains a zonotopic set, the output is a zonotope.\nOtherwise, the return type is a polytope either in constraint representation or in vertex representation, depending on the dimension and the properties of M. For details, see LazySets.project.\n\nNotes\n\nThis function can be used to project a reach-set onto a lower-dimensional sub-space. The projection is concrete, and it consists of mapping the reach-set X = set(R) to a new reach-set through to MX, where M is the projection matrix associated with the given variables vars.\n\nTo project onto the time variable, use the index 0. For instance, (0, 1) projects onto the time variable and the first variable in R.\n\n\n\n\n\n","category":"function"},{"location":"lib/reachsets/#Taylor-model-reach-sets-1","page":"Reach-sets","title":"Taylor model reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"AbstractTaylorModelReachSet\nTaylorModelReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractTaylorModelReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractTaylorModelReachSet","text":"AbstractTaylorModelReachSet{N}\n\nAbstract type for all reach sets types that represent a Taylor model.\n\nNotes\n\nThe parameter N refers to the numerical type of the representation.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#ReachabilityAnalysis.TaylorModelReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.TaylorModelReachSet","text":"TaylorModelReachSet{N} <: AbstractTaylorModelReachSet{N}\n\nTaylor model reach-set represented as a vector taylor models in one variable (namely, the \"time\" variable) whose coefficients are multivariate polynomials (namely in the \"space\" variables).\n\nNotes\n\nThe parameter N refers to the numerical type of the representation.\n\nIn TMJets, the space variables are normalized to the interval [-1, 1].\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Template-reach-sets-1","page":"Reach-sets","title":"Template reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"TemplateReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.TemplateReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.TemplateReachSet","text":"TemplateReachSet{N, VN<:AbstractVector{N}} <: AbstractReachSet{N}\n\nReach set that stores the support function of a set at a give set of directions.\n\nNotes\n\nThe parameter N refers to the numerical type of the representation. This reach-set implicitly represents a set by a set of directions and support functions. set(R::TemplateReachSet) returns a polyhedron in half-space representation.\n\nApart from the getter functions inherited from the AbstractReachSet interface, the following methods are available:\n\ndirections(R)  – return the set of directions normal to the faces of this reach-set\nsup_func(R)    – return the vector of support function evaluations\nsup_func(R, i) – return the i-th coordinate of the vector of support function evaluatons\n\n\n\n\n\n","category":"type"},{"location":"man/hybrid/#Hybrid-differential-equations-1","page":"Hybrid systems","title":"Hybrid differential equations","text":"","category":"section"},{"location":"man/hybrid/#","page":"Hybrid systems","title":"Hybrid systems","text":"bouncing ball","category":"page"},{"location":"lib/algorithms/INT/#","page":"INT","title":"INT","text":"INT","category":"page"},{"location":"lib/algorithms/INT/#ReachabilityAnalysis.INT","page":"INT","title":"ReachabilityAnalysis.INT","text":"INT{N, AM} <: AbstractContinuousPost\n\nImplementation of an interval-based integrator for one-dimensional systems.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional) approximation model for the discretization of the                   continuous ODE; see the Notes below for available options\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\n\nThe default approximation model used in this algorithm is:\n\nForward(sih=:concrete, exp=:base, phi2=:base, setops=:Interval)\n\nIn particular, the setops=:Interval flag specifies that intermediate computations in the discretization are done using interval arithmetic.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"Home","title":"Home","text":"DocTestSetup = :(using ReachabilityAnalysis)","category":"page"},{"location":"#ReachabilityAnalysis.jl-1","page":"Home","title":"ReachabilityAnalysis.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Methods to compute sets of states reachable by dynamical systems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nReachabilityAnalysis is still under development. If you have questions, find a bug, or have ideas for improvements, feel free to open an issue or make a pull request on the project's GitHub page. You can also find us at the JuliaReach gitter channel.","category":"page"},{"location":"#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This library implements reachability analysis methods for systems of ordinary differential equations (ODEs), for both continuous and hybrid dynamical systems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The following types of ODEs are currently supported:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Continuous ODEs with linear dynamics.\nContinuous ODEs with non-linear dynamics.\nHybrid systems with piecewise-affine dynamics.\nHybrid systems with non-linear dynamics.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For hybrid systems, the transitions may be space-triggered or time-triggered (or both).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In all the problems mentioned above, the library can handle uncertainties in the sets of initial states, inputs, or parameter variation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We refer to the Algorithms section for detailed descriptions of the algorithms available, as well as the references to the technical literature.","category":"page"},{"location":"#Application-domains-1","page":"Home","title":"Application domains","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Reachability analysis has applications in diverse domains such as:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Safety verification: Determining whether a system is safe, i.e. to verify if it does not enter into a region of unsafe sets. Typical applications are assessing the critical distance between autonomous vehicles or robots, or critical concentration of chemicals in a reactor.\nValidation of control strategies: Checking if the system trajectories stay in a region around a reference trajectory, or reach a goal region around a setpoint, for any admissible value of the non-deterministic inputs, initial conditions or noise.\nController synthesis: Finding parameter sets of controllers that satisfy safety or performance constraints.\nDeep neural network verification: Providing formal guarantees for the network behavior subject to perturbations in the inputs, e.g. detecting that small changes in an input image do not cause the network o misclassify it.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We refer to the technical literature for further applications.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In Julia v1.0 or later you can install ReachabilityAnalysis from the Pkg REPL (press ] in the Julia REPL to enter the pkg> mode):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add ReachabilityAnalysis","category":"page"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"DocTestSetup = :(using ReachabilityAnalysis)","category":"page"},{"location":"lib/discretize/#Discretization-1","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"Pages = [\"discretize.md\"]\nDepth = 3","category":"page"},{"location":"lib/discretize/#Approximation-models-1","page":"Discretization","title":"Approximation models","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"ReachabilityAnalysis.AbstractApproximationModel","category":"page"},{"location":"lib/discretize/#ReachabilityAnalysis.AbstractApproximationModel","page":"Discretization","title":"ReachabilityAnalysis.AbstractApproximationModel","text":"AbstractApproximationModel\n\nAbstract supertype for all approximation models.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#Discretize-API-1","page":"Discretization","title":"Discretize API","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"TODO: document discretize.","category":"page"},{"location":"lib/discretize/#Exponentiation-1","page":"Discretization","title":"Exponentiation","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"ReachabilityAnalysis._exp\nReachabilityAnalysis.Φ₁\nReachabilityAnalysis.Φ₂","category":"page"},{"location":"lib/discretize/#ReachabilityAnalysis._exp","page":"Discretization","title":"ReachabilityAnalysis._exp","text":"_exp(A::AbstractMatrix, δ::Float64, method::Symbol)\n\nCompute the matrix exponential e^Aδ.\n\nInput\n\nA       – matrix\nδ       – step size\nmethod  – symbol with the method used to take the matrix exponential of A;              possible options are:\n:base – use the scaling and squaring method implemented in Julia standard            library; see ?exp for details\n:lazy – return a lazy wrapper type around the matrix exponential using            the implementation LazySets.SparseMatrixExp\n:pade – apply Pade approximant method to compute the matrix exponential            of a sparse matrix (requires Expokit)\n\nOutput\n\nA matrix or a lazy wrapper of the matrix exponential, depending on method.\n\nNotes\n\nIf the algorithm \"lazy\" is used, evaluations of the action of the matrix exponential are done with the expmv implementation from Expokit (but see LazySets#1312 for the planned generalization to other backends).\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Φ₁","page":"Discretization","title":"ReachabilityAnalysis.Φ₁","text":"Φ₁(A, δ, method)\n\nCompute the series\n\nΦ₁(A δ) = _i=0^ dfracδ^i+1(i+1)A^i\n\nwhere A is a square matrix of order n and δ  mathbbR_0.\n\nInput\n\nA      – coefficient matrix\nδ      – step size\nmethod – (optional, default: \"base\") the method used to take the matrix             exponential of the coefficient matrix; see the documentation of             _exp_Aδ for available options\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nWe use the method from [1]. If A is invertible, Φ₁ can be computed as\n\nΦ₁(A δ) = A^-1(e^δA - I_n)\n\nwhere I_n is the identity matrix of order n.\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP = exp beginpmatrix\nAδ  δI_n  0 \n0  0      δI_n \n0  0      0\nendpmatrix\n\nIt can be shown that Φ₁(A, δ) = P[1:n, (n+1):2*n].\n\n[1] Frehse, Goran, et al. \"SpaceEx: Scalable verification of hybrid systems.\" International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2011.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Φ₂","page":"Discretization","title":"ReachabilityAnalysis.Φ₂","text":"Φ₂(A, δ, method)\n\nCompute the series\n\nΦ₂(A δ) = _i=0^ dfracδ^i+2(i+2)A^i\n\nwhere A is a square matrix of order n and δ  mathbbR_0.\n\nInput\n\nA      – coefficient matrix\nδ      – step size\nmethod – the method used to take the matrix             exponential of the coefficient matrix; see the documentation of             _exp_Aδ for available options\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nWe use the method from [1]. If A is invertible, Φ₂ can be computed as\n\nΦ₂(A δ) = A^-2(e^δA - I_n - δA)\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP = exp beginpmatrix\nAδ  δI_n  0 \n0  0  δI_n \n0  0  0\nendpmatrix\n\nIt can be shown that Φ₂(A, δ) = P[1:n, (2*n+1):3*n].\n\n[1] Frehse, Goran, et al. \"SpaceEx: Scalable verification of hybrid systems.\" International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2011.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"Let A  mathbbR^nn and for t  0 consider the integral int_0^t e^Aξdξ. If A is invertible, this integral (...)","category":"page"},{"location":"lib/algorithms/BFFPSV18/#BFFPSV18-1","page":"BFFPSV18","title":"BFFPSV18","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"BFFPSV18","category":"page"},{"location":"lib/algorithms/BFFPSV18/#ReachabilityAnalysis.BFFPSV18","page":"BFFPSV18","title":"ReachabilityAnalysis.BFFPSV18","text":"BFFPSV18{N, ST, NI, IDX, BLK, RBLK CBLK} <: AbstractContinuousPost\n\nImplementation of .... TODO\n\nFields\n\nTODO\n\nNotes\n\nReferences\n\nTODO\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/BFFPSV18/#Reachable-states-approximation-1","page":"BFFPSV18","title":"Reachable states approximation","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"In a nutshell, we overapproximate the reachable states of an affine system by solving a set-based recurrence. The key idea is that we first decompose the system into (low-dimensional) subsystems and later compose the results as a Cartesian product. Thus we have to solve many cheap problems instead of one hard problem. Since solving the recurrence scales superlinearly with the dimension, this approach is very scalable.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Decomposition-error-1","page":"BFFPSV18","title":"Decomposition error","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"Decomposition typically involves a loss in precision, and so does this approach. The good thing is that we can decompose the recurrence as well, which allows us to analyze each of the subsystems independently by only referring to the initial states of the other subsystems. Consequently, there are two main sources for precision loss:","category":"page"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"Decomposition of the initial states: If two subsystems are interdependent initially.\nRepresentation of the reachable states as a Cartesian product: If two subsystems are interdependent in the dynamics.\nRepresentation of the reachable states in general: The reachable states of affine systems cannot be represented precisely in all cases. This is a problem that all approaches suffer from. We overapproximate the reachable states by (unions of) convex polytopes.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Checking-safety-properties-1","page":"BFFPSV18","title":"Checking safety properties","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"The problem of checking a safety property can be reduced to a reachability problem. We provide special support for this reduction by inlining the property check into the reachable states computation. This has two benefits:","category":"page"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"We fail fast when the property is violated in our abstraction.\nThe check is usually cheaper than computing the full reachable states. This is because we are often only interested in an upper or lower bound of a variable.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Lazy-sets-1","page":"BFFPSV18","title":"Lazy sets","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"To represent sets of states, we use the LazySets package which provides exact but lazy (i.e. symbolic) representations of common sets.","category":"page"}]
}
