var documenterSearchIndex = {"docs":
[{"location":"references/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"This page includes the original references for each algorithm included in this library. If you use ReachabilityAnalysis.jl for your own work, do consider citing the appropriate original reference.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"[G05] Girard, A. (2005, March). Reachability of uncertain linear systems using       zonotopes.       In International Workshop on Hybrid Systems: Computation and Control (pp. 291-305).       Springer, Berlin, Heidelberg.\n[GLM06] Girard, A., Le Guernic, C., & Maler, O. (2006, March).        Efficient computation of reachable sets of linear time-invariant systems        with inputs.        In International Workshop on Hybrid Systems: Computation and Control (pp. 257-271).        Springer, Berlin, Heidelberg.","category":"page"},{"location":"lib/solution_types/#","page":"Solution types","title":"Solution types","text":"go","category":"page"},{"location":"about/#About-1","page":"About","title":"About","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Pages = [\"about.md\"]","category":"page"},{"location":"about/#Contributing-1","page":"About","title":"Contributing","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"If you like this package, consider contributing! We welcome bug reports, examples that can be added to the documentation, or new feature proposals.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Below some conventions that we follow when contributing to this package are detailed. For specific guidelines on documentation, see the JuliaReach Developer's Documentation.","category":"page"},{"location":"about/#Branches-1","page":"About","title":"Branches","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"Each pull request (PR) should be pushed in a new branch with the name of the author followed by a descriptive name, e.g. t/mforets/my_feature. If the branch is associated to a previous discussion in one issue, we use the name of the issue for easier lookup, e.g. t/mforets/7.","category":"page"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)-1","page":"About","title":"Unit testing and continuous integration (CI)","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This project is synchronized with Travis CI, such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to understand and fix the failing doctests if they exist. We develop in Julia v0.6.0, but for experimentation we also build on the nightly branch.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"To run the unit tests locally, you should do:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes test/runtests.jl","category":"page"},{"location":"about/#Contributing-to-the-documentation-1","page":"About","title":"Contributing to the documentation","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This documentation is written in Markdown, and it relies on Documenter.jl to produce the HTML layout. To build the docs, run make.jl:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"man/linear/#Linear-ordinary-differential-equations-1","page":"Linear ODEs","title":"Linear ordinary differential equations","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In this section we begin by solving a simple scalar equation. Then we introduce the functionality to solve systems of equations. Finally, we consider a higher-dimensional example and some","category":"page"},{"location":"man/linear/#Example-1","page":"Linear ODEs","title":"Example","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Our first example is the one-dimensional differential equation x(t) = -x over the time interval 0  t  T. Suppose that the initial state can be any point in the interval x(0)  0 1.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"using ReachabilityAnalysis\nP = @ivp x' = -x, x(0) ∈ 0..1\nsol = solve(P)\n\nusing Plots\nplot(sol, label=\"Flowpipe\")","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"The analytic solution for an initial point x_0 is x(t) = e^-tx_0, which is also plotted","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"plot!(, t -> -exp(-t), label=\"Analytic solution\")","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"As we have seen in this example, the solution process mainly consists of three steps:","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"formulating the mathematical problem\nsolving the problem\nextracting the results, eg. plotting, or projecting","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In the following example we consider a higher-dimensional ODE to illustrate in some detail these steps.","category":"page"},{"location":"man/linear/#Solution-process-1","page":"Linear ODEs","title":"Solution process","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"To illustrate the solution process, we consider a spring-mass system illustrated in the following figure.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"The mass is m and the elastic constant of the spring is k.","category":"page"},{"location":"man/linear/#Problem-formulation-1","page":"Linear ODEs","title":"Problem formulation","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In this case the system is not given as a set of first-order ODEs, so we will make that transformation as a first step.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Transforming higher-order into a first-order system.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Formulating the mathematical problem involves writing the system as a first-order","category":"page"},{"location":"man/linear/#Solving-the-problem-1","page":"Linear ODEs","title":"Solving the problem","text":"","category":"section"},{"location":"man/linear/#Extracting-the-results,-eg.-plotting,-or-projecting-1","page":"Linear ODEs","title":"Extracting the results, eg. plotting, or projecting","text":"","category":"section"},{"location":"man/linear/#Using-static-arrays-1","page":"Linear ODEs","title":"Using static arrays","text":"","category":"section"},{"location":"man/linear/#Higher-dimensional-ODEs-1","page":"Linear ODEs","title":"Higher-dimensional ODEs","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"combination of state variables to obtain an output","category":"page"},{"location":"man/linear/#Using-lazy-exponentiation-1","page":"Linear ODEs","title":"Using lazy exponentiation","text":"","category":"section"},{"location":"man/nonlinear/#Nonlinear-ordinary-differential-equations-1","page":"Nonlinear ODEs","title":"Nonlinear ordinary differential equations","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"lotka-volterra","category":"page"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/flowpipes/#Flowpipes-1","page":"Flowpipes","title":"Flowpipes","text":"","category":"section"},{"location":"lib/flowpipes/#Abstract-types-1","page":"Flowpipes","title":"Abstract types","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"AbstractFlowpipe\nAbstractReachSet","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.AbstractFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.AbstractFlowpipe","text":"AbstractFlowpipe\n\nAbstract type representing a flowpipe.\n\nNotes\n\nA flowpipe is the set union of an array of reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#ReachabilityAnalysis.AbstractReachSet","page":"Flowpipes","title":"ReachabilityAnalysis.AbstractReachSet","text":"AbstractReachSet{N}\n\nAbstract type for all reach-sets types.\n\nNotes\n\nA reach-set is a set representation X associated to a given time span Δt.\n\nIn its simplest form, we represent reach-sets with a struct that wraps the tuple (X, Δt), where X corresponds to a geometric set, eg. a polytope, and Δt is the interval with the time span associated to this reach-set.\n\nThis type is parametric in N. The parameter N represents for the type of numerical coefficient used in the representation (typically, N = Float64).\n\nAlthough concrete subtypes of AbstractReachSet may represent the set X in different ways, or carry additional information as an extra type field, they should all implement the AbstractReachSet interface to enable shared functionality for reach-set types. In particular, each concrete subtype should implement the following methods:\n\nset    – return the geometric set\nsetrep – return the type of the set representation\ntspan  – return the time interval span\ntstart – return the initial time\ntend   – return the final time\ndim    – return ambient dimension of the reach-set\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Interface-functions-1","page":"Flowpipes","title":"Interface functions","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"set\nsetrep\ntstart\ntend\ntspan","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.set","page":"Flowpipes","title":"ReachabilityAnalysis.set","text":"set(R::AbstractReachSet)\n\nReturn the geometric set represented by this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe set wrapped by the given reach-set.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#ReachabilityAnalysis.setrep","page":"Flowpipes","title":"ReachabilityAnalysis.setrep","text":"setrep(R::AbstractReachSet)\n\nReturn the type of the set representation of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nType of the set representation of the given reach-set.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tstart","page":"Flowpipes","title":"ReachabilityAnalysis.tstart","text":"tstart(R::AbstractReachSet)\n\nReturn the initial time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the initial time of the given reach-set.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tend","page":"Flowpipes","title":"ReachabilityAnalysis.tend","text":"tend(R::AbstractReachSet)\n\nReturn the final time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the final time of the given reach-set.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tspan","page":"Flowpipes","title":"ReachabilityAnalysis.tspan","text":"tspan(R::AbstractReachSet)\n\nReturn time span of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe interval representing the time span of the given reach-set.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#Reachable-set-1","page":"Flowpipes","title":"Reachable set","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"ReachSet","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.ReachSet","page":"Flowpipes","title":"ReachabilityAnalysis.ReachSet","text":"ReachSet{N, ST<:LazySet{N}} <: AbstractLazyReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation.\n\nFields\n\nX  – set\nΔt – time interval\n\nNotes\n\nA ReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype LazySet. For efficiency reasons, ST should be concretely typed.\n\nBy assumption the coordinates in this reach-set are associated to the integers 1, …, n. The function vars_idx returns such tuple.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Sparse-reachable-set-1","page":"Flowpipes","title":"Sparse reachable set","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"SparseReachSet","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.SparseReachSet","page":"Flowpipes","title":"ReachabilityAnalysis.SparseReachSet","text":"SparseReachSet{N, ST<:LazySet{N}, D} <: AbstractReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation, together with a tuple of variables associated to this reach-set.\n\nFields\n\nX        – set\nΔt       – time interval\nvars_idx – tuple of variable indices represented by the set X\n\nNotes\n\nA SparseReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype of LazySet (ideally, concrete). Moreover, this type also stores information about the variables (also named coordinates, or by abuse of notation, dimensions) corresponding to the set X.\n\nFor instance in the ambient space n=5, one may have a SparseReachSet whose variables tuple is vars = (4, 5, 6), i.e. representing a three-dimensional projection of the full-dimensional reach-set. In consequence, the dimension of X doesn't match the length of vars, in general\n\nIn this type, the parameter N represents the numerical type of the LazySet (typically, Float64), the type ST represents the set representation used, and D denotes the dimension of this sparse reach set. Note that, in contrast to ReachSet, for SparseReachSet the number of dimensions is part of the type information.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Type-stable-flowpipe-1","page":"Flowpipes","title":"Type-stable flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"Flowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.Flowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.Flowpipe","text":"Flowpipe{N, RT<:AbstractReachSet{N}} <: AbstractFlowpipe\n\nType that wraps a flowpipe.\n\nFields\n\nXk  – set\next – extension dictionary; field used by extensions\n\nNotes\n\nThe dimension of the flowpipe corresponds to the dimension of the underlying reach-sets; in this type, it is is assumed that the dimension is the same for the different reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Hybrid-flowpipe-1","page":"Flowpipes","title":"Hybrid flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"HybridFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.HybridFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.HybridFlowpipe","text":"HybridFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of possibly differen types.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\n\n\n\n\n","category":"type"},{"location":"man/parametric/#Parametric-reachability-1","page":"Parametric reachability","title":"Parametric reachability","text":"","category":"section"},{"location":"man/parametric/#Theory-1","page":"Parametric reachability","title":"Theory","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"Parametric reachability consist of . . . ","category":"page"},{"location":"man/parametric/#Example-1","page":"Parametric reachability","title":"Example","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"We reconsider the example from Section (REF?), but we add an uncertain parameter α that accounts for the variation in the ...","category":"page"},{"location":"man/parametric/#Spring-mass-system-1","page":"Parametric reachability","title":"Spring-mass system","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"Here we consider variations in the constant k and perform reachability . . . .","category":"page"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"In this section we present two problems related to thermal conduction. The first problem, Heat flow PDE, is a model representing the heat xyz. The second model, Hybrid thermostat model, is","category":"page"},{"location":"man/applications/thermal_conduction/#Heat-flow-PDE-1","page":"-","title":"Heat flow PDE","text":"","category":"section"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"ver uno de los SLICOT benchmarks\nver tambien un paper de Zhi Han","category":"page"},{"location":"man/applications/thermal_conduction/#Hybrid-thermostat-model-1","page":"-","title":"Hybrid thermostat model","text":"","category":"section"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"The system is modeled as a two-mode hybrid automaton.","category":"page"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"este ya lo tenemos\nver la referencia","category":"page"},{"location":"introduction/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"In simple terms, reachability analysis is concerned with studying the sets of states that a system can reach, starting from a set of initial states and under the influence of a set of input trajectories and parameter values. More technically, we define the reachable set at a given time point delta in mathbbR, also known as the reach-set for the ODE","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"x = f(x(t) u(t) p(t) t)","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"as given by","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"mathcalR(δ) = left x(δ) = int_0^δ f(x(t) u(t) p(t) t) dt x(0)  X_0 u(t)  mathcalU p(t)  mathcalP right","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Here X_0 denotes the set of initial states, mathcalU denotes the input set, and mathcalP denotes the parameter values. For practical problems, the set mathcalR(δ) cannot be obtained exactly, and reachability methods aim at computing suitable over-approximations (or under-approximations) of it.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"We define the reachable set associated to a time interval 0 δ, also known as the flowpipe, as","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"mathcalF(0  δ) = _t in 0 δ mathcalR(δ)","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Reachability methods are used to compute rigorous approximations of the flowpipe for continuous or hybrid systems, in bounded time or unbounded time horizon. Here we use the term rigorous in the formal, or mathematical sense, that no solution \"escapes\" the flowpipe, for any trajectory that satisfies the constraints (initial states, inputs, and noise).","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"On the other hand, the amount of computation required depends heavily on the particular problem statement. One notable example is safety verification, which simply stated requires to prove that the flowpipe does not intersect a region of \"bad states\". In this setting, one can often reason about the flowpipe lazily, i.e. without actually computing it in full.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Up to now we have discussed about the continuous case only, but there is a rich literature in hybrid systems reachability; hybrid here means those dynamical systems which are given by one or more continuous-time dynamics (often, systems of ODEs in each mode or location) coupled with discrete transitions between continuous modes. In our context it is standard to model these systems using the terminology of hybrid automata, and we also model hybrid systems with such framework in this library. The concept of reach-set, flowpipe and safety verification are naturally extended to hybrid automata, although there is the additional complication that the flowpipe must include the behaviors for all possible transitions between discrete modes that are compatible with the dynamics.","category":"page"},{"location":"man/hybrid/#Hybrid-differential-equations-1","page":"Hybrid systems","title":"Hybrid differential equations","text":"","category":"section"},{"location":"man/hybrid/#","page":"Hybrid systems","title":"Hybrid systems","text":"bouncing ball","category":"page"},{"location":"man/setrep/#Set-representations-1","page":"Set representations","title":"Set representations","text":"","category":"section"},{"location":"man/setrep/#Reach-sets-1","page":"Set representations","title":"Reach-sets","text":"","category":"section"},{"location":"man/setrep/#Flowpipes-1","page":"Set representations","title":"Flowpipes","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#BFFPSV18-1","page":"BFFPSV18","title":"BFFPSV18","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#Reachable-states-approximation-1","page":"BFFPSV18","title":"Reachable states approximation","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"In a nutshell, we overapproximate the reachable states of an affine system by solving a set-based recurrence. The key idea is that we first decompose the system into (low-dimensional) subsystems and later compose the results as a Cartesian product. Thus we have to solve many cheap problems instead of one hard problem. Since solving the recurrence scales superlinearly with the dimension, this approach is very scalable.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Decomposition-error-1","page":"BFFPSV18","title":"Decomposition error","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"Decomposition typically involves a loss in precision, and so does this approach. The good thing is that we can decompose the recurrence as well, which allows us to analyze each of the subsystems independently by only referring to the initial states of the other subsystems. Consequently, there are two main sources for precision loss:","category":"page"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"Decomposition of the initial states: If two subsystems are interdependent initially.\nRepresentation of the reachable states as a Cartesian product: If two subsystems are interdependent in the dynamics.\nRepresentation of the reachable states in general: The reachable states of affine systems cannot be represented precisely in all cases. This is a problem that all approaches suffer from. We overapproximate the reachable states by (unions of) convex polytopes.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Checking-safety-properties-1","page":"BFFPSV18","title":"Checking safety properties","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"The problem of checking a safety property can be reduced to a reachability problem. We provide special support for this reduction by inlining the property check into the reachable states computation. This has two benefits:","category":"page"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"We fail fast when the property is violated in our abstraction.\nThe check is usually cheaper than computing the full reachable states. This is because we are often only interested in an upper or lower bound of a variable.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Lazy-sets-1","page":"BFFPSV18","title":"Lazy sets","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"To represent sets of states, we use the LazySets package which provides exact but lazy (i.e. symbolic) representations of common sets.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"DocTestSetup = :(using ReachabilityAnalysis)","category":"page"},{"location":"#ReachabilityAnalysis.jl-1","page":"Home","title":"ReachabilityAnalysis.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Methods to compute sets of states reachable by dynamical systems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nReachabilityAnalysis is still under development. If you have questions, find a bug, or have ideas for improvements, feel free to open an issue or make a pull request on the project's GitHub page. You can also find us at the JuliaReach gitter channel.","category":"page"},{"location":"#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This library implements reachability analysis methods for systems of ordinary differential equations (ODEs), for both continuous and hybrid dynamical systems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The following types of ODEs are currently supported:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Continuous ODEs with linear dynamics.\nContinuous ODEs with non-linear dynamics.\nHybrid systems with piecewise-affine dynamics.\nHybrid systems with non-linear dynamics.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For hybrid systems, the transitions may be space-triggered or time-triggered (or both).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In all the problems mentioned above, the library can handle uncertainties in the sets of initial states, inputs, or parameter variation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We refer to the Algorithms section for detailed descriptions of the algorithms available, as well as the references to the technical literature.","category":"page"},{"location":"#Application-domains-1","page":"Home","title":"Application domains","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Reachability analysis has applications in diverse domains such as:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Safety verification: Determining whether a system is safe, i.e. to verify if it does not enter into a region of unsafe sets. Typical applications are assessing the critical distance between autonomous vehicles or robots, or critical concentration of chemicals in a reactor.\nValidation of control strategies: Checking if the system trajectories stay in a region around a reference trajectory, or reach a goal region around a setpoint, for any admissible value of the non-deterministic inputs, initial conditions or noise.\nController synthesis: Finding parameter sets of controllers tha satisfy safety or performance constraints.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Deep neural network verification: Providing formal guarantees for the network behavior subject to perturbations in the inputs, e.g. detecting that small changes in an input image do not cause the network o misclassify it.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We refer to the technical literature for further applications.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In Julia v1.0 or later you can install ReachabilityAnalysis from the Pkg REPL (press ] in the Julia REPL the to enter pkg> mode):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add ReachabilityAnalysis","category":"page"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"DocTestSetup = :(using ReachabilityAnalysis)","category":"page"},{"location":"lib/discretize/#Discretization-1","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"Pages = [\"discretize.md\"]\nDepth = 3","category":"page"},{"location":"lib/discretize/#Linear-systems-1","page":"Discretization","title":"Linear systems","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"ReachabilityAnalysis.discretize\nReachabilityAnalysis.discretize_interpolation\nReachabilityAnalysis.discretize_firstorder\nReachabilityAnalysis.discretize_nobloating\nReachabilityAnalysis.discretize_interval_matrix","category":"page"},{"location":"lib/discretize/#Exponentiation-1","page":"Discretization","title":"Exponentiation","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"Let A  mathbbR^nn and for t  0 consider the integral int_0^t e^Aξdξ. If A is invertible, this integral","category":"page"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"ReachabilityAnalysis.exp_Aδ\nReachabilityAnalysis.Φ₁\nReachabilityAnalysis.Φ₂","category":"page"},{"location":"lib/discretize/#ReachabilityAnalysis.Φ₁","page":"Discretization","title":"ReachabilityAnalysis.Φ₁","text":"Φ₁(A, δ, method)\n\nCompute the series\n\nΦ₁(A δ) = _i=0^ dfracδ^i+1(i+1)A^i\n\nwhere A is a square matrix of order n and δ  mathbbR_0.\n\nInput\n\nA           – coefficient matrix\nδ           – step size\nmethod  – (optional, default: \"base\") the method used to take the matrix                   exponential of the coefficient matrix; see the documentation of                   exp_Aδ for available options\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nWe use the method from [1]. If A is invertible, Φ₁ can be computed as\n\nΦ₁(A δ) = A^-1(e^δA - I_n)\n\nwhere I_n is the identity matrix of order n.\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP = exp beginpmatrix\nAδ  δI_n  0 \n0  0      δI_n \n0  0      0\nendpmatrix\n\nIt can be shown that Φ₁(A, δ) = P[1:n, (n+1):2*n].\n\n[1] Frehse, Goran, et al. \"SpaceEx: Scalable verification of hybrid systems.\" International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2011.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Φ₂","page":"Discretization","title":"ReachabilityAnalysis.Φ₂","text":"Φ₂(A, δ, method)\n\nCompute the series\n\nΦ₂(A δ) = _i=0^ dfracδ^i+2(i+2)A^i\n\nwhere A is a square matrix of order n and δ  mathbbR_0.\n\nInput\n\nA           – coefficient matrix\nδ           – step size\nmethod       – the method used to take the matrix                   exponential of the coefficient matrix; see the documentation of                   exp_Aδ for available options\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nWe use the method from [1]. If A is invertible, Φ₂ can be computed as\n\nΦ₂(A δ) = A^-2(e^δA - I_n - δA)\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP = exp beginpmatrix\nAδ  δI_n  0 \n0  0  δI_n \n0  0  0\nendpmatrix\n\nIt can be shown that Φ₂(A, δ) = P[1:n, (2*n+1):3*n].\n\n[1] Frehse, Goran, et al. \"SpaceEx: Scalable verification of hybrid systems.\" International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2011.\n\n\n\n\n\n","category":"function"}]
}
