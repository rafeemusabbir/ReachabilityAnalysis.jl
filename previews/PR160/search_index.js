var documenterSearchIndex = {"docs":
[{"location":"man/setrep/#Set-representations-1","page":"Set representations","title":"Set representations","text":"","category":"section"},{"location":"man/setrep/#Reach-sets-1","page":"Set representations","title":"Reach-sets","text":"","category":"section"},{"location":"man/setrep/#Flowpipes-1","page":"Set representations","title":"Flowpipes","text":"","category":"section"},{"location":"references/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"This page includes references to the scientific works that we have applied throughout this library. Although the list is not meant to be exhaustive, we think it should give a solid starting place for those who want to explore further.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"If you use ReachabilityAnalysis.jl for your own work, please consider citing the appropriate original reference(s). For this purpose we provide the BibTeX citation in each case.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"If you find that a reference here is missing, if you spot a typo or want to update a reference, do not hesitate to contact us by email, or open an issue. Sorting is alphabetic.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ALU95]-1","page":"References","title":"[ALU95]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Alur, R., Courcoubetis, C., Halbwachs, N., Henzinger, T. A., Ho, P. H., Nicollin, X., ... & Yovine, S. (1995). The algorithmic analysis of hybrid systems. Theoretical computer science, 138(1), 3-34.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@article{alur1995algorithmic,\n  title={The algorithmic analysis of hybrid systems},\n  author={Alur, Rajeev and Courcoubetis, Costas and Halbwachs, Nicolas and Henzinger, Thomas A and Ho, Pei-Hsin and Nicollin, Xavier and Olivero, Alfredo and Sifakis, Joseph and Yovine, Sergio},\n  journal={Theoretical computer science},\n  volume={138},\n  number={1},\n  pages={3--34},\n  year={1995},\n  publisher={Citeseer}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ALT10]-1","page":"References","title":"[ALT10]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Althoff, Matthias. Reachability analysis and its application to the safety assessment of autonomous cars.. Diss. Technische Universität München, 2010.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{althoff2010reachability,\n  title={Reachability analysis and its application to the safety assessment of autonomous cars},\n  author={Althoff, Matthias},\n  year={2010},\n  school={Technische Universit{\\\"a}t M{\\\"u}nchen}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ASB07]-1","page":"References","title":"[ASB07]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"M. Althoff, O. Stursberg, and M. Buss. Reachability analysis of linear systems with uncertain parameters and inputs. In Proc. of the 46th IEEE Conference on Decision and Control, pages 726–732, 2007.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{althoff2007reachability,\n  title={Reachability analysis of linear systems with uncertain parameters and inputs},\n  author={Althoff, Matthias and Stursberg, Olaf and Buss, Martin},\n  booktitle={2007 46th IEEE Conference on Decision and Control},\n  pages={726--732},\n  year={2007},\n  organization={IEEE}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[BFFPSV18]-1","page":"References","title":"[BFFPSV18]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Bogomolov, S., Forets, M., Frehse, G., Viry, F., Podelski, A., & Schilling, C. (2018, April). Reach set approximation through decomposition with low-dimensional sets and high-dimensional matrices.. In Proceedings of the 21st International Conference on Hybrid Systems: Computation and Control (part of CPS Week) (pp. 41-50).","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{bogomolov2018reach,\n  title={Reach set approximation through decomposition with low-dimensional sets and high-dimensional matrices},\n  author={Bogomolov, Sergiy and Forets, Marcelo and Frehse, Goran and Viry, Fr{\\'e}d{\\'e}ric and Podelski, Andreas and Schilling, Christian},\n  booktitle={Proceedings of the 21st International Conference on Hybrid Systems: Computation and Control (part of CPS Week)},\n  pages={41--50},\n  year={2018}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[CHEN15]-1","page":"References","title":"[CHEN15]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Chen, Xin. Reachability Analysis of Non-Linear Hybrid Systems Using Taylor Models.. Diss. Fachgruppe Informatik, RWTH Aachen University, 2015.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{chen2015reachability,\n  title={Reachability Analysis of Non-Linear Hybrid Systems Using Taylor Models},\n  author={Chen, Xin},\n  year={2015},\n  school={Fachgruppe Informatik, RWTH Aachen University}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[COMB03]-1","page":"References","title":"[COMB03]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Combastel, C. A state bounding observer based on zonotopes. 2003 European Control Conference (ECC). IEEE, 2003.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{combastel2003state,\n  title={A state bounding observer based on zonotopes},\n  author={Combastel, C},\n  booktitle={2003 European Control Conference (ECC)},\n  pages={2589--2594},\n  year={2003},\n  organization={IEEE}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[FRE11]-1","page":"References","title":"[FRE11]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Frehse, G., Le Guernic, C., Donzé, A., Cotton, S., Ray, R., Lebeltel, O., ... & Maler, O. (2011, July). SpaceEx: Scalable verification of hybrid systems. In International Conference on Computer Aided Verification (pp. 379-395). Springer, Berlin, Heidelberg.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{frehse2011spaceex,\n  title={SpaceEx: Scalable verification of hybrid systems},\n  author={Frehse, Goran and Le Guernic, Colas and Donz{\\'e}, Alexandre and Cotton, Scott and Ray, Rajarshi and Lebeltel, Olivier and Ripado, Rodolfo and Girard, Antoine and Dang, Thao and Maler, Oded},\n  booktitle={International Conference on Computer Aided Verification},\n  pages={379--395},\n  year={2011},\n  organization={Springer}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[FRE16]-1","page":"References","title":"[FRE16]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Frehse, G. (2016). Scalable verification of hybrid systems.. (Habilitation á diriger des recherches, Univ. Grenoble Alpes).","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{frehse2016scalable,\n  title={Scalable verification of hybrid systems},\n  author={Frehse, Goran},\n  year={2016}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[FR12]-1","page":"References","title":"[FR12]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Frehse, Goran, and Rajarshi Ray. Flowpipe-Guard Intersection for Reachability Computations with Support Functions. ADHS. 2012.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{frehse2012flowpipe,\n  title={Flowpipe-Guard Intersection for Reachability Computations with Support Functions.},\n  author={Frehse, Goran and Ray, Rajarshi},\n  booktitle={ADHS},\n  pages={94--101},\n  year={2012}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[GIR04]-1","page":"References","title":"[GIR04]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Girard, Antoine. Analyse algorithmique des systemes hybrides.. Diss. Institut National Polytechnique de Grenoble-INPG, 2004.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{girard2004analyse,\n  title={Analyse algorithmique des systemes hybrides},\n  author={Girard, Antoine},\n  year={2004},\n  school={Institut National Polytechnique de Grenoble-INPG}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[GIR05]-1","page":"References","title":"[GIR05]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Girard, A. (2005, March). Reachability of uncertain linear systems using zonotopes. In International Workshop on Hybrid Systems: Computation and Control (pp. 291-305). Springer, Berlin, Heidelberg.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{girard2005reachability,\n  title={Reachability of uncertain linear systems using zonotopes},\n  author={Girard, Antoine},\n  booktitle={International Workshop on Hybrid Systems: Computation and Control},\n  pages={291--305},\n  year={2005},\n  organization={Springer}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[GIR13]-1","page":"References","title":"[GIR13]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Girard, Antoine. Computational approaches to analysis and control of hybrid systems.. Diss. 2013.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{girard2013computational,\n  title={Computational approaches to analysis and control of hybrid systems},\n  author={Girard, Antoine},\n  year={2013}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[GLGM06]-1","page":"References","title":"[GLGM06]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Girard, A., Le Guernic, C., & Maler, O. (2006, March). Efficient computation of reachable sets of linear time-invariant systems with inputs. In International Workshop on Hybrid Systems: Computation and Control (pp. 257-271). Springer, Berlin, Heidelberg.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{girard2006efficient,\n  title={Efficient computation of reachable sets of linear time-invariant systems with inputs},\n  author={Girard, Antoine and Le Guernic, Colas and Maler, Oded},\n  booktitle={International Workshop on Hybrid Systems: Computation and Control},\n  pages={257--271},\n  year={2006},\n  organization={Springer}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[HG19]-1","page":"References","title":"[HG19]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"el Hakim, Viktorio S., and Marco JG Bekooij. Reachability Analysis of Hybrid Automata with Clocked Linear Dynamics.. Proceedings of the 22nd International Workshop on Software and Compilers for Embedded Systems. 2019.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{el2019reachability,\n  title={Reachability Analysis of Hybrid Automata with Clocked Linear Dynamics},\n  author={el Hakim, Viktorio S and Bekooij, Marco JG},\n  booktitle={Proceedings of the 22nd International Workshop on Software and Compilers for Embedded Systems},\n  pages={27--36},\n  year={2019}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[JOL]-1","page":"References","title":"[JOL]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Joldes, M. M. (2011). Approximations polynomiales rigoureuses et applications.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"(Doctoral dissertation, Lyon, École normale supérieure).","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{joldes2011approximations,\n  title={Approximations polynomiales rigoureuses et applications},\n  author={Joldes, Mioara Maria},\n  year={2011},\n  school={Lyon, {\\'E}cole normale sup{\\'e}rieure}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[KEK18]-1","page":"References","title":"[KEK18]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Kekatos, Nikolaos. Vérification formelle des systèmes cyber-physiques dans le processus industriel de la conception basée sur modèle..","category":"page"},{"location":"references/#","page":"References","title":"References","text":"Diss. Grenoble Alpes, 2018.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{kekatos2018verification,\n  title={V{\\'e}rification formelle des syst{\\`e}mes cyber-physiques dans le processus industriel de la conception bas{\\'e}e sur mod{\\`e}le},\n  author={Kekatos, Nikolaos},\n  year={2018},\n  school={Grenoble Alpes}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[LGG09]-1","page":"References","title":"[LGG09]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Le Guernic, Colas, and Antoine Girard. Reachability analysis of linear systems using support functions.. Nonlinear Analysis: Hybrid Systems 4.2 (2010): 250-262.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@article{le2010reachability,\n  title={Reachability analysis of linear systems using support functions},\n  author={Le Guernic, Colas and Girard, Antoine},\n  journal={Nonlinear Analysis: Hybrid Systems},\n  volume={4},\n  number={2},\n  pages={250--262},\n  year={2010},\n  publisher={Elsevier}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[LGG09b]-1","page":"References","title":"[LGG09b]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Le Guernic, Colas, and Antoine Girard. Reachability analysis of hybrid systems using support functions. International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2009.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{le2009reachability,\n  title={Reachability analysis of hybrid systems using support functions},\n  author={Le Guernic, Colas and Girard, Antoine},\n  booktitle={International Conference on Computer Aided Verification},\n  pages={540--554},\n  year={2009},\n  organization={Springer}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[LG09]-1","page":"References","title":"[LG09]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Le Guernic, Colas. Calcul d’Atteignabilité des Systemes Hybrides a Partie Continue Linéaire.. Diss. PhD thesis, Université Grenoble I, 2009.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{le2009calcul,\n  title={Calcul d’Atteignabilit{\\'e} des Systemes Hybrides a Partie Continue Lin{\\'e}aire},\n  author={Le Guernic, Colas},\n  year={2009},\n  school={Citeseer}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[RAY12]-1","page":"References","title":"[RAY12]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Ray, Rajarshi. Calcul d'Atteignabilité des systèmes hybrides avec des fonctions de support. Diss. 2012.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{ray2012calcul,\n  title={Calcul d'Atteignabilit{\\'e} des syst{\\`e}mes hybrides avec des fonctions de support},\n  author={Ray, Rajarshi},\n  year={2012}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ROC18]-1","page":"References","title":"[ROC18]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Rocca, Alexandre. Formal methods for modelling and validation of biological models.. Diss. Grenoble Alpes, 2018.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{rocca2018formal,\n  title={Formal methods for modelling and validation of biological models},\n  author={Rocca, Alexandre},\n  year={2018},\n  school={Grenoble Alpes}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[SCHI18]-1","page":"References","title":"[SCHI18]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Schilling, Christian-Matthias. Fundamental techniques for the scalable analysis of systems.. Diss. University of Freiburg, Freiburg im Breisgau, Germany, 2018.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{schilling2018fundamental,\n  title={Fundamental techniques for the scalable analysis of systems.},\n  author={Schilling, Christian-Matthias},\n  year={2018},\n  school={University of Freiburg, Freiburg im Breisgau, Germany}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[SCHU19]-1","page":"References","title":"[SCHU19]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Schupp, Stefan. State set representations and their usage in the reachability analysis of hybrid systems.. No. RWTH-2019-08875. Fachgruppe Informatik, 2019.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@techreport{schupp2019state,\n  title={State set representations and their usage in the reachability analysis of hybrid systems},\n  author={Schupp, Stefan},\n  year={2019},\n  institution={Fachgruppe Informatik}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[YS18]-1","page":"References","title":"[YS18]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Yang, Xuejiao, and Joseph K. Scott. A comparison of zonotope order reduction techniques.. Automatica 95 (2018): 378-384.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@article{yang2018comparison,\n  title={A comparison of zonotope order reduction techniques},\n  author={Yang, Xuejiao and Scott, Joseph K},\n  journal={Automatica},\n  volume={95},\n  pages={378--384},\n  year={2018},\n  publisher={Elsevier}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"lib/algorithms/TMJets/#","page":"TMJets","title":"TMJets","text":"TMJets","category":"page"},{"location":"lib/algorithms/TMJets/#ReachabilityAnalysis.TMJets","page":"TMJets","title":"ReachabilityAnalysis.TMJets","text":"TMJets{N, DM<:AbstractDisjointnessMethods} <: AbstractContinuousPost\n\nValidated integration with Taylor models, based on the algorithm implemented by Luis Benet and David Sanders in TalorModels.jl.\n\nFields\n\nmax_steps – (optional, default: 2000) maximum number of steps in the                validated integration x = f(x)\nabs_tol   – (optional, default: 1e-10) absolute tolerance\norderT    – (optional, default: 8) order of the Taylor model in time\norderQ    – (optional, default: 2) order of the Taylor models for jet transport variables\nintersection_method – (optional, default: ZonotopeEnclosure()) defines the method to                          compute the intersection of the taylor model flowpipe with the invariant\nadaptive  – (optional, default: true) if true, try decreasing the absolute                tolerance each time step validation fails, until min_abs_tol is reached\n\nNotes\n\nTODO: Add references.\n\n\n\n\n\n","category":"type"},{"location":"man/linear_high_dim/#Exploiting-structure-1","page":"Exploiting structure","title":"Exploiting structure","text":"","category":"section"},{"location":"man/linear_high_dim/#","page":"Exploiting structure","title":"Exploiting structure","text":"In this section we consider reachability analysis for subsets of variables of a given linear system. Let","category":"page"},{"location":"man/linear_high_dim/#","page":"Exploiting structure","title":"Exploiting structure","text":"x(t) = Ax(t) + v(t)","category":"page"},{"location":"man/linear_high_dim/#","page":"Exploiting structure","title":"Exploiting structure","text":"a = 1\nb = 2\na + b","category":"page"},{"location":"lib/solutions/#","page":"Solutions","title":"Solutions","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/solutions/#Solutions-1","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"lib/solutions/#Abstract-interface-1","page":"Solutions","title":"Abstract interface","text":"","category":"section"},{"location":"lib/solutions/#","page":"Solutions","title":"Solutions","text":"ReachabilityAnalysis.AbstractSolution","category":"page"},{"location":"lib/solutions/#ReachabilityAnalysis.AbstractSolution","page":"Solutions","title":"ReachabilityAnalysis.AbstractSolution","text":"AbstractSolution\n\nAbstract supertype of all solution types of a rechability problem.\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#Solution-of-a-reachability-problem-1","page":"Solutions","title":"Solution of a reachability problem","text":"","category":"section"},{"location":"lib/solutions/#","page":"Solutions","title":"Solutions","text":"ReachabilityAnalysis.ReachSolution","category":"page"},{"location":"lib/solutions/#ReachabilityAnalysis.ReachSolution","page":"Solutions","title":"ReachabilityAnalysis.ReachSolution","text":"ReachSolution{FT<:AbstractFlowpipe, ST<:AbstractPost} <: AbstractSolution\n\nType that wraps the solution of a reachability problem as a sequence of lazy sets, and a dictionary of options.\n\nFields\n\nXk       – the list of AbstractReachSets\noptions  – the dictionary of options\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#","page":"Solutions","title":"Solutions","text":"TODO: document other methods in solutions.jl.","category":"page"},{"location":"man/applications/epidemic/#","page":"Epidemic disease","title":"Epidemic disease","text":"https://doktormike.gitlab.io/post/covid-19/s","category":"page"},{"location":"about/#About-1","page":"About","title":"About","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"page"},{"location":"about/#Contributing-1","page":"About","title":"Contributing","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"If you like this package, consider contributing! We welcome bug reports, examples that can be added to the documentation, or new feature proposals.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Below we list some conventions that we follow when contributing to this package. For specific guidelines on documentation see the JuliaReach Developer's Documentation.","category":"page"},{"location":"about/#Branches-1","page":"About","title":"Branches","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"Each pull request (PR) should be pushed in a new branch with the name of the author followed by a descriptive name, e.g. mforets/my_feature. If the branch is associated to a previous discussion in an issue, we use the name of the issue for easier lookup, e.g. mforets/7.","category":"page"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)-1","page":"About","title":"Unit testing and continuous integration (CI)","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This project is synchronized with Travis CI, such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to understand and fix the failing tests if they exist. We support Julia v1.0 and develop in the latest stable release. For experimentation we also build on the nightly branch.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"To run the unit tests locally, you should do:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes test/runtests.jl","category":"page"},{"location":"about/#Contributing-to-the-documentation-1","page":"About","title":"Contributing to the documentation","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This documentation is written in Markdown, and it relies on Documenter.jl to produce the HTML layout. To build the documentation, run make.jl:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"lib/algorithms/ASB07/#","page":"ASB07","title":"ASB07","text":"ASB07","category":"page"},{"location":"lib/algorithms/ASB07/#ReachabilityAnalysis.ASB07","page":"ASB07","title":"ReachabilityAnalysis.ASB07","text":"ASB07{N, AM, RM, S, R} <: AbstractContinuousPost\n\nImplementation of Althoff - Stursberg - Buss algorithm for reachability of linear systems with uncertain parameters and inputs using zonotopes.\n\nFields\n\nδ                – step-size of the discretization\napprox_model     – (optional, default: Forward) approximation model;                       see Notes below for possible options\nmax_order        – (optional, default: 5) maximum zonotope order\nreduction_method – (optional, default: GIR05()) zonotope order reduction method used\nstatic           – (optional, default: false) if true, convert the problem data                       to statically sized arrays\nrecursive        – (optional default: true) if true, use the implementation that                       recursively computes each reach-set; otherwise, use the implementation                       that unwraps the sequence until the initial set\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – type of the approximation model\nRM – type associated to the reduction method\nS  – value type associated to the static option\nR  – value type associated to the recursive option\n\nThe sole parameter which doesn't have a default value is the step-size, associated to the type parameter N.\n\nThe default approximation model is\n\napprox_model=CorrectionHull(order=10, exp=:base)\n\nHere, CorrectionHull refers to an implementation of the interval matrix approximation method described in [ASB07]. For technicalities on interval matrix operations, we refer to the package IntervalMatrices.jl.\n\nReferences\n\nThe main ideas behind this algorithm can be found in [ASB07]. These methods are discussed at length in the dissertation [ALT10].\n\nRegarding the zonotope order reduction methods, we refer to [COMB03], [GIR05] and the review article [YS18].\n\n\n\n\n\n","category":"type"},{"location":"man/linear/#Linear-ordinary-differential-equations-1","page":"Linear ODEs","title":"Linear ordinary differential equations","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In this section we show how to solve initial value problems with sets of initial conditions. First we consider the simple scalar equation x(t) = -x(t), where x(0) may be any point in a given initial interval mathcalX_0. Then we consider the spring-mass system, a second order linear ODE studied in introductory physics courses. For that system we show an example of how to compute and project the flowpipe, and then plot the variables of interest.","category":"page"},{"location":"man/linear/#Example-1","page":"Linear ODEs","title":"Example","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Our first example is an initial-value problem for the one-dimensional differential equation","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"x(t) = -x(t)qquad 0  t  T = 40","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"with initial condition x(0)  045 055.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"We can compute the flowpipe using solve:","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"using ReachabilityAnalysis, Plots\n\n# define the initial-value problem\nprob = @ivp(x' = -x, x(0) ∈ 0.45 .. 0.55)\n\n# solve it\nsol = solve(prob, T=4.0)\n\n# plot the solution, where the index 0 corresponds to the \"time\" variable\nplot(sol, vars=(0, 1), label=\"Flowpipe\", xlab=\"t\", ylab=\"x(t)\", linewidth=0.3)","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In practice, analytic solutons of ODEs are unknown. However, in this simple case we know that for an initial point x_0 in mathbbR, the solution is x(t) = x_0 e^-t. We can plot some trajectories in the same plot as the flowpipe, to see that the trajectories are indeed inside the flowpipe, as expected.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"f(t, x0) = x0 * exp(-t)\n\nplot!(t -> f(t, 0.45), xlims=(0, 4), label=\"Analytic sol., x(0) = 0.45\", color=\"red\")\nplot!(t -> f(t, 0.55), xlims=(0, 4), label=\"Analytic sol., x(0) = 0.55\", color=\"red\")","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"This example illustrates that the solution process mainly consists of three steps:","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"(1) Formulating the mathematical problem, in the form of an initial-value problem     with possibly uncertain initial states or inputs.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"(2) Solving the problem, either with the default algorithm or specifying the algorithm     and some of its options.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"(3) Extracting the results, either to visualize with a plot, or to project onto     the relevant variables for further study.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Below we give some further details of this solution step for the simple scalar equation presented above.","category":"page"},{"location":"man/linear/#Problem-formulation-1","page":"Linear ODEs","title":"Problem formulation","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Solution process","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"To illustrate the solution process, we consider a spring-mass system illustrated in the following figure.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"The mass is m and the elastic constant of the spring is k.","category":"page"},{"location":"man/linear/#Solving-the-initial-value-problem-1","page":"Linear ODEs","title":"Solving the initial-value problem","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In this case the system is not given as a set of first-order ODEs, so we will make that transformation as a first step.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Transforming higher-order into a first-order system.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Formulating the mathematical problem involves writing the system as a first-order","category":"page"},{"location":"man/linear/#Analyzing-the-solution-1","page":"Linear ODEs","title":"Analyzing the solution","text":"","category":"section"},{"location":"man/linear/#Spring-mass-system-1","page":"Linear ODEs","title":"Spring-mass system","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In the following example we consider a spring-mass system which is a linear ODE with two-degrees of freedom.","category":"page"},{"location":"man/nonlinear/#Nonlinear-ordinary-differential-equations-1","page":"Nonlinear ODEs","title":"Nonlinear ordinary differential equations","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"In this section we illustrate the flowpipe computation for a nonlinear system.","category":"page"},{"location":"man/nonlinear/#Model-description-1","page":"Nonlinear ODEs","title":"Model description","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Our running example is the Lotka-Volterra model. The 2-dimensional Lotka-Volterra system depicts the populations change of a class of predators and a class of preys. The growth rate of preys’ population x over time is given by","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"dotx = xcdot (alpha - beta cdot y)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"wherein  alpha beta are constant parameters and y is the population of predators.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"It gives that the number of preys grows exponentially without predation.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"The population growth of predators is governed by the differential equation","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"doty = -ycdot (gamma - deltacdot x)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"wherein  gamma delta are constant parameters.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We set those parameters as  alpha = 15   beta = 1   gamma = 3  and  delta = 1.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"using ReachabilityAnalysis\n\n@taylorize function lotka_volterra!(du, u, p, t)\n    local α, β, γ, δ = 1.5, 1.0, 3.0, 1.0\n    du[1] = u[1] * (α - β*u[2])\n    du[2] = -u[2] * (γ - δ*u[1])\n    return du\nend","category":"page"},{"location":"man/nonlinear/#Reachability-settings-1","page":"Nonlinear ODEs","title":"Reachability settings","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"The reachability settings are taken from this resource.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We consider the initial set  xin 4852 y in 1822.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"X₀ = Hyperrectangle(low=[4.8, 1.8], high=[5.2, 2.2])\n\nprob = @ivp(x' = lotka_volterra!(x), dim: 2, x(0) ∈ X₀)","category":"page"},{"location":"man/nonlinear/#Results-1","page":"Nonlinear ODEs","title":"Results","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We compute the flowpipe using the TMJets algorithm for the time horizon 05:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"sol = solve(prob, T=5.0)\n\nsetrep(sol)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We can change to the zonotopic overapproximation of the flowpipe using the overapproximate function:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"sol = overapproximate(sol, Zonotope)\n\nsetrep(sol)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Finally we plot the solution in phase-space:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"using Plots\n\nplot(sol, vars=(1, 2), xlab=\"x\", ylab=\"y\", lw=0.2, color=:lightblue, lab=\"Flowpipe\")\nplot!(X₀, color=:orange, lab=\"Xo\")","category":"page"},{"location":"lib/algorithms/GLGM06/#","page":"GLGM06","title":"GLGM06","text":"GLGM06","category":"page"},{"location":"lib/algorithms/GLGM06/#ReachabilityAnalysis.GLGM06","page":"GLGM06","title":"ReachabilityAnalysis.GLGM06","text":"GLGM06{N, AM, S, D, NG, P, RM} <: AbstractContinuousPost\n\nImplementation of Girard - Le Guernic - Maler algorithm for reachability of linear systems using zonotopes.\n\nFields\n\nδ                – step-size of the discretization\napprox_model     – (optional, default: Forward) approximation model;                       see Notes below for possible options\nmax_order        – (optional, default: 5) maximum zonotope order\nstatic           – (optional, default: false) if true, convert the problem data                       to statically sized arrays\ndim              – (optional default: missing) ambient dimension\nngens            – (optional, default: missing) number of generators\npreallocate      – (optional, default: true) if true, use the implementation                       which preallocates the zonotopes prior to applying the update rule\nreduction_method – (optional, default: GIR05()) zonotope order reduction method used\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\nS  – value type associated to the static option\nD  – value type associated to the dimension of the system\nNG – value type associated to the number of generators\nP  – value type associated to the preallocate option\nRM – type associated to the reduction method\n\nThe sole parameter which doesn't have a default value is the step-size, associated to the type parameter N. Parameters D and NG are optionally specified (default to Missing). These parameters are needed for implementations that require the size of the zonotopes to be known (fixed) at compile time, namely the static=true version of this algorithm. Otherwise, the number of generators is not necessarily fixed.\n\nThe default approximation model is\n\napprox_model=Forward(sih=:concrete, exp=:base, setops=:lazy)\n\nHere, Forward refers to the forward-time adaptation of the approximation model from Lemma 3 in [FRE11]. Some of the options to compute this approximation can be specified, see the documentation of Forward for details.\n\nReferences\n\nThe main ideas behind this algorithm can be found in [GIR05] and [GLGM06]. These methods are discussed at length in the dissertation [LG09].\n\nRegarding the zonotope order reduction methods, we refer to [COMB03], [GIR05] and the review article [YS18].\n\nRegarding the approximation model, we use an adaptation of a result in [FRE11].\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/LGG09/#","page":"LGG09","title":"LGG09","text":"LGG09","category":"page"},{"location":"lib/algorithms/LGG09/#ReachabilityAnalysis.LGG09","page":"LGG09","title":"ReachabilityAnalysis.LGG09","text":"LGG09{N, AM, TN<:AbstractDirections} <: AbstractContinuousPost\n\nImplementation of Girard - Le Guernic algorithm for reachability analysis using support functions.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\ntemplate     – struct that holds the directions (either lazily or concretely)                   for each support function evaluation defining the template\nstatic       – (optional, default: false) if true, use statically sized arrays\nthreaded     – (optional, default: true) if true, use multi-threading parallelism                   to compute the support function along each direction\n\nNotes\n\nThe type fields are:\n\nN        – number type of the step-size\nAM       – type of the approximation model\nTN       – type of the abstract directions that define the template\n\nReferences\n\nThe is an implementation of the algorithm from [LGG09].\n\nThese methods are described at length in the dissertation [LG09].\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/BOX/#","page":"BOX","title":"BOX","text":"BOX","category":"page"},{"location":"lib/algorithms/BOX/#ReachabilityAnalysis.BOX","page":"BOX","title":"ReachabilityAnalysis.BOX","text":"BOX{N, AM, S, D, R} <: AbstractContinuousPost\n\nImplementation of a reachability method for linear systems using box approximations.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\nstatic\ndim          – (optional default: missing) ambient dimension\nrecursive    – (optional default: false) if true, use the implementation that                   recursively computes each reach-set; otherwise, use the implementation                   that unwraps the sequence until the initial set\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\nS  – value type for the static option\nD  – value type for the dimension\nR  – value type for the recursive option\n\nThe default approximation model is:\n\nForward(sih=:concrete, exp=:base, setops=:lazy)\n\nThis algorithm solves the set-based recurrence equation X_k+1 = ΦX_k  V_k by computing a tight hyperrectangular over-approximation of X_k+1 at each step k  mathbbN. The recursive implementation uses the previously computed set X_k to compute X_k+1. However, it is known that this method incurs wrapping effects. The non-recursive implementation instead computes X_k+1 by unwrapping the discrete recurrence until X_0 = Ω₀, at the expense of computing powers of the matrix Φ. These ideas are discussed in [BFFPSV18].\n\nReferences\n\nThis algorithm is essentially a non-decomposed version of the method in [BFFPSV18], using hyperrectangles as set representation. For a general introduction we refer to the dissertation [LG09].\n\nRegarding the approximation model, by default we use an adaptation of the method presented in [FRE11].\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/flowpipes/#Flowpipes-1","page":"Flowpipes","title":"Flowpipes","text":"","category":"section"},{"location":"lib/flowpipes/#Abstract-interface-1","page":"Flowpipes","title":"Abstract interface","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"AbstractFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.AbstractFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.AbstractFlowpipe","text":"AbstractFlowpipe\n\nAbstract type representing a flowpipe.\n\nNotes\n\nA flowpipe is the set union of an array of reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"The following functions are available at the interface level.","category":"page"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"basetype(::Type{<:AbstractFlowpipe})\nLazySets.ρ(::AbstractVector, ::AbstractFlowpipe)\nLazySets.σ(::AbstractVector, ::AbstractFlowpipe)\nLazySets.dim(::AbstractFlowpipe)\nset(::AbstractFlowpipe, ::Integer)\ntstart(::AbstractFlowpipe)\ntend(::AbstractFlowpipe)\ntspan(::AbstractFlowpipe)","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.basetype-Tuple{Type{#s28} where #s28<:ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.basetype","text":"basetype(T::Type{<:AbstractFlowpipe})\n\nReturn the base type of the given flowpipe type (i.e., without type parameters).\n\nInput\n\nT – flowpipe type, used for dispatch\n\nOutput\n\nThe base type of T.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.ρ-Tuple{AbstractArray{T,1} where T,ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.ρ","text":"LazySets.ρ(d::AbstractVector, fp::AbstractFlowpipe)\n\nInput\n\nd  – direction\nfp – flowpipe\n\nOutput\n\nThe support function of the flowpipe along the given direction d.\n\nNotes\n\nIn this fallback implementation, the flowpipe behaves like the union of the reach-sets, i.e. the implementation is analogue to that of a LazySet.UnionSetArray.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.σ-Tuple{AbstractArray{T,1} where T,ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.σ","text":"LazySets.σ(d::AbstractVector, fp::AbstractFlowpipe)\n\nInput\n\nd  – direction\nfp – flowpipe\n\nOutput\n\nThe support vector of the flowpipe along the given direction d.\n\nNotes\n\nIn this fallback implementation, the flowpipe behaves like the union of the reach-sets, i.e. the implementation is analogue to that of a LazySet.UnionSetArray.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.dim-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.dim","text":"LazySets.dim(fp::AbstractFlowpipe)\n\nInput\n\nfp – flowpipe\n\nOutput\n\nAn integer representing the ambient dimension of the flowpipe.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.set-Tuple{ReachabilityAnalysis.AbstractFlowpipe,Integer}","page":"Flowpipes","title":"ReachabilityAnalysis.set","text":"set(fp::AbstractFlowpipe, ind::Integer)\n\nReturn the geometric set represented by this flowpipe at the given index.\n\nInput\n\nfp  – flowpipe\nind – index (from 1 to length(flowpipe))\n\nOutput\n\nThe set wrapped by the flowpipe at the given index.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tstart-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tstart","text":"tstart(fp::AbstractFlowpipe)\n\nReturn the initial time of this flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nA float representing the initial time of the given flowpipe. The fallback is computed by taking the initial time of the first reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tend-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tend","text":"tend(fp::AbstractFlowpipe)\n\nReturn the final time of this flowpipe.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the initial time of the given flowpipe. The fallback is computed by taking the final time of the last reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tspan-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tspan","text":"tspan(fp::AbstractFlowpipe)\n\nReturn time span of this flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nThe interval representing the time span of the given flowpipe. The fallback is computed as (tstart(fp), tend(fp)), see tstart(::AbstractFlowpipe) and tend(::AbstractFlowpipe) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#Flowpipe-1","page":"Flowpipes","title":"Flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"Flowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.Flowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.Flowpipe","text":"Flowpipe{N, RT<:AbstractReachSet{N}, VRT<:AbstractVector{RT}} <: AbstractFlowpipe\n\nType that wraps a flowpipe.\n\nFields\n\nXk  – set\next – extension dictionary; field used by extensions\n\nNotes\n\nThe dimension of the flowpipe corresponds to the dimension of the underlying reach-sets; in this type, it is is assumed that the dimension is the same for the different reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"The following methods are available.","category":"page"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"shift","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.shift","page":"Flowpipes","title":"ReachabilityAnalysis.shift","text":"shift(R::AbstractReachSet, t0::Number)\n\nPerform a time-shift of the given reach-set.\n\nInput\n\nR  – reach-set\nt0 – number that corresponds to the time-shift\n\nOutput\n\nA new reach-set of the same type of R such that its time-span has been shifted by t0.\n\n\n\n\n\nshift(fp::Flowpipe{N, ReachSet{N, ST}}, t0::Number) where {N, ST}\n\nReturn the time-shifted flowpipe by the given number.\n\nInput\n\nfp – flowpipe\nt0 – time shift\n\nOutput\n\nA new flowpipe such that the time-span of each constituent reach-set has been shifted by t0.\n\nNotes\n\nSee also Shift for the lazy counterpart.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#Hybrid-flowpipe-1","page":"Flowpipes","title":"Hybrid flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"HybridFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.HybridFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.HybridFlowpipe","text":"HybridFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of the same type, such that they are contiguous in time.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\nThis type assumes that the flowpipes are contiguous in time. This means that the final time the i-th flowpipe matches the start time of the i+1-th flowpipe.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Mixed-flowpipe-1","page":"Flowpipes","title":"Mixed flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"MixedFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.MixedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.MixedFlowpipe","text":"MixedFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of the same time, such that they are not necessarily contiguous in time.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\nThis type does not assume that the flowpipes are contiguous in time.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Shifted-flowpipe-1","page":"Flowpipes","title":"Shifted flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"ShiftedFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.ShiftedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.ShiftedFlowpipe","text":"ShiftedFlowpipe{FT<:AbstractFlowpipe, NT<:Number} <: AbstractFlowpipe\n\nType that lazily represents a flowpipe that has been shifted in time.\n\nFields\n\nF  – original flowpipe\nt0 – time shift\n\nNotes\n\nThis type can wrap any concrete subtype of AbstractFlowpipe, and the extra field t0 is such that the time spans of each reach-set in F are shifted by the amount t0 (which should be a subtype of Number).\n\nA convenience constructor alias Shift is given.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Partitioned-flowpipe-1","page":"Flowpipes","title":"Partitioned flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"PartitionedFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.PartitionedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.PartitionedFlowpipe","text":"PartitionedFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of possibly different types.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\n\n\n\n\n","category":"type"},{"location":"man/parametric/#Parametric-reachability-1","page":"Parametric reachability","title":"Parametric reachability","text":"","category":"section"},{"location":"man/parametric/#Theory-1","page":"Parametric reachability","title":"Theory","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"Parametric reachability consist of . . . ","category":"page"},{"location":"man/parametric/#Example-1","page":"Parametric reachability","title":"Example","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"We reconsider the example from Section (REF?), but we add an uncertain parameter α that accounts for the variation in the ...","category":"page"},{"location":"man/parametric/#Spring-mass-system-1","page":"Parametric reachability","title":"Spring-mass system","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"Here we consider variations in the constant k and perform reachability . . . .","category":"page"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"In this section we present two problems related to thermal conduction. The first problem, Heat flow PDE, is a model representing the heat xyz. The second model, Hybrid thermostat model, is","category":"page"},{"location":"man/applications/thermal_conduction/#Heat-flow-PDE-1","page":"-","title":"Heat flow PDE","text":"","category":"section"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"ver uno de los SLICOT benchmarks\nver tambien un paper de Zhi Han","category":"page"},{"location":"man/applications/thermal_conduction/#Hybrid-thermostat-model-1","page":"-","title":"Hybrid thermostat model","text":"","category":"section"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"The system is modeled as a two-mode hybrid automaton.","category":"page"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"este ya lo tenemos\nver la referencia","category":"page"},{"location":"introduction/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"In simple terms, reachability analysis is concerned with studying the sets of states that a system can reach, starting from a set of initial states and under the influence of a set of input trajectories and parameter values. More technically, we define the reachable set at a given time point delta in mathbbR, also known as the reach-set for the ODE","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"x(t) = f(x(t) u(t) p(t) t)","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"as given by","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"mathcalR(δ) = left x(δ) = int_0^δ f(x(t) u(t) p(t) t) dt x(0)  X_0 u(t)  mathcalU p(t)  mathcalP right","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Here X_0 denotes the set of initial states, mathcalU denotes the input set, and mathcalP denotes the parameter values. For practical problems, the set mathcalR(δ) cannot be obtained exactly, and reachability methods aim at computing suitable over-approximations (or under-approximations) of it.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"We define the reachable set associated to a time interval 0 δ, also known as the flowpipe, as","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"mathcalF(0 δ) = _t in 0 δ mathcalR(t)","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Reachability methods are used to compute rigorous approximations of the flowpipe for continuous or hybrid systems, in bounded time or unbounded time horizon. Here we use the term rigorous in the formal, or mathematical sense, that no solution \"escapes\" the flowpipe, for any trajectory that satisfies the constraints (initial states, inputs, and noise).","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"On the other hand, the amount of computation required depends heavily on the particular problem statement. One notable example is safety verification, which simply stated requires to prove that the flowpipe does not intersect a region of \"bad states\". In this setting, one can often reason about the flowpipe lazily, i.e. without actually computing it in full.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Up to now we have discussed about the continuous case only, but there is a rich literature in hybrid systems reachability; hybrid here means those dynamical systems which are given by one or more continuous-time dynamics (often, systems of ODEs in each mode or location) coupled with discrete transitions between continuous modes. In our context it is standard to model these systems using the terminology of hybrid automata, and we also model hybrid systems with such framework in this library. The concept of reach-set, flowpipe and safety verification are naturally extended to hybrid automata, although there is the additional complication that the flowpipe must include the behaviors for all possible transitions between discrete modes that are compatible with the dynamics.","category":"page"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/reachsets/#Reach-sets-1","page":"Reach-sets","title":"Reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#Abstract-interface-1","page":"Reach-sets","title":"Abstract interface","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"AbstractReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractReachSet","text":"AbstractReachSet{N}\n\nAbstract type for all reach-sets types.\n\nNotes\n\nA reach-set is a set representation X associated to a given time span Δt.\n\nIn its simplest form, we represent reach-sets with a struct that wraps the tuple (X, Δt), where X corresponds to a geometric set, eg. a polytope, and Δt is the interval with the time span associated to this reach-set.\n\nThis type is parametric in N. The parameter N represents for the type of numerical coefficient used in the representation (typically, N = Float64).\n\nAlthough concrete subtypes of AbstractReachSet may represent the set X in different ways, or carry additional information as an extra type field, they should all implement the AbstractReachSet interface to enable shared functionality for reach-set types. In particular, each concrete subtype should implement the following methods:\n\nset    – return the geometric set\nsetrep – return the type of the set representation\ntspan  – return the time interval span\ntstart – return the initial time\ntend   – return the final time\ndim    – return ambient dimension of the reach-set\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"The functions are available at the interface level.","category":"page"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"basetype(::Type{<:AbstractReachSet})\nset(::AbstractReachSet)\nsetrep(::AbstractReachSet)\ntspan(::AbstractReachSet)\ntstart(::AbstractReachSet)\ntend(::AbstractReachSet)\ndim(::AbstractReachSet)\ncopy(::AbstractReachSet)\nshift(::AbstractReachSet)","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.basetype-Tuple{Type{#s28} where #s28<:ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.basetype","text":"basetype(T::Type{<:AbstractReachSet})\n\nReturn the base type of the given reach-set type (i.e., without type parameters).\n\nInput\n\nT – reach-set type, used for dispatch\n\nOutput\n\nThe base type of T.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.set-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.set","text":"set(R::AbstractReachSet)\n\nReturn the geometric set represented by this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe set wrapped by the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.setrep-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.setrep","text":"setrep(R::AbstractReachSet)\n\nReturn the type of the set representation of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nType of the set representation of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tspan-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tspan","text":"tspan(R::AbstractReachSet)\n\nReturn time span of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe interval representing the time span of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tstart-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tstart","text":"tstart(R::AbstractReachSet)\n\nReturn the initial time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the initial time of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tend-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tend","text":"tend(R::AbstractReachSet)\n\nReturn the final time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the final time of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#LazySets.dim-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"LazySets.dim","text":"dim(R::AbstractReachSet)\n\nReturn the ambient dimension of the reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nAn integer corresponding to the ambient dimension of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#Base.copy-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"Base.copy","text":"copy(R::AbstractReachSet)\n\nReturn a copy of the given reach-set.\n\nInput\n\nR  – reach-set\n\nOutput\n\nA new reach-set of the sam type and the same field values as R.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.shift-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.shift","text":"shift(fp::Flowpipe{N, ReachSet{N, ST}}, t0::Number) where {N, ST}\n\nReturn the time-shifted flowpipe by the given number.\n\nInput\n\nfp – flowpipe\nt0 – time shift\n\nOutput\n\nA new flowpipe such that the time-span of each constituent reach-set has been shifted by t0.\n\nNotes\n\nSee also Shift for the lazy counterpart.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"AbstractLazyReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractLazyReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractLazyReachSet","text":"AbstractLazyReachSet{N} <: AbstractReachSet{N}\n\nAbstract type for all reach-set types that use a LazySet for the underlying set representation.\n\nNotes\n\nAn AbstractLazyReachSet is the interface for reach-sets such that the geometric set is represented by any subtype of LazySet.\n\nThis types implements the LazySets interface, namely support function (ρ), support vector (σ) and ambient dimension (dim) functions. Hence, these functions directly apply to concrete subtypes of an AbstractLazyReachSet. The set wrapped by this type is obtained through set(R).\n\nThe following functions should be implemented by any concrete subtype:\n\nreconstruct – create a new instance of the given reach-set with a different                  set representation but sharing the other fields, i.e. the same                  time span (and the same for other fields, if applicable)\n\nIn addition to the functions inherited from AbstractReachSet, the following are available:\n\nproject  – projection of a reach-set\nshift    – time-shift of a reach-set\nvars_idx – tuple of integers associated to the variables of the given reach-set\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Reachable-set-1","page":"Reach-sets","title":"Reachable set","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"ReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.ReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.ReachSet","text":"ReachSet{N, ST<:LazySet{N}} <: AbstractLazyReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation.\n\nFields\n\nX  – set\nΔt – time interval\n\nNotes\n\nA ReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype LazySet. For efficiency reasons, ST should be concretely typed.\n\nBy assumption the coordinates in this reach-set are associated to the integers 1, …, n. The function vars_idx returns such tuple.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Sparse-reachable-set-1","page":"Reach-sets","title":"Sparse reachable set","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"SparseReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.SparseReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.SparseReachSet","text":"SparseReachSet{N, ST<:LazySet{N}, D} <: AbstractReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation, together with a tuple of variables associated to this reach-set.\n\nFields\n\nX        – set\nΔt       – time interval\nvars_idx – tuple of variable indices represented by the set X\n\nNotes\n\nA SparseReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype of LazySet (ideally, concrete). Moreover, this type also stores information about the variables (also named coordinates, or by abuse of notation, dimensions) corresponding to the set X.\n\nFor instance in the ambient space n=5, one may have a SparseReachSet whose variables tuple is vars = (4, 5, 6), i.e. representing a three-dimensional projection of the full-dimensional reach-set. In consequence, the dimension of X doesn't match the length of vars, in general\n\nIn this type, the parameter N represents the numerical type of the LazySet (typically, Float64), the type ST represents the set representation used, and D denotes the dimension of this sparse reach set. Note that, in contrast to ReachSet, for SparseReachSet the number of dimensions is part of the type information.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Projections-1","page":"Reach-sets","title":"Projections","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"project","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.project","page":"Reach-sets","title":"ReachabilityAnalysis.project","text":"project(R::Union{ReachSet, SparseReachSet}, vars::NTuple{D, Int};\n        [check_vars]::Bool=true) where {D}\n\nProjects a reach-set onto the subspace spanned by the given variables.\n\nInput\n\nR          – reach-set\nvars       – tuple of variables for the projection\ncheck_vars – (optional, default: true) if true, check that the given variable                 indices vars are a subset of the variables of R\n\nOutput\n\nA SparseReachSet whose variable indices are given by vars.\n\nThe type of the new reach-set depends on the type of the reach-set R:\n\nIf R contains a hyperrectangular set, the output is a hyperrectangle.\nIf R contains a zonotopic set, the output is a zonotope.\nOtherwise, the return type is a polytope either in constraint representation or in vertex representation, depending on the dimension and the properties of M. For details, see LazySets.project.\n\nNotes\n\nThis function can be used to project a reach-set onto a lower-dimensional sub-space. The projection is concrete, and it consists of mapping the reach-set X = set(R) to a new reach-set through to MX, where M is the projection matrix associated with the given variables vars.\n\nTo project onto the time variable, use the index 0. For instance, (0, 1) projects onto the time variable and the first variable in R.\n\n\n\n\n\n","category":"function"},{"location":"lib/reachsets/#Taylor-model-reach-sets-1","page":"Reach-sets","title":"Taylor model reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"AbstractTaylorModelReachSet\nTaylorModelReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractTaylorModelReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractTaylorModelReachSet","text":"AbstractTaylorModelReachSet{N}\n\nAbstract type for all reach sets types that represent a Taylor model.\n\nNotes\n\nThe parameter N refers to the numerical type of the representation.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#ReachabilityAnalysis.TaylorModelReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.TaylorModelReachSet","text":"TaylorModelReachSet{N} <: AbstractTaylorModelReachSet{N}\n\nTaylor model reach-set represented as a vector taylor models in one variable (namely, the \"time\" variable) whose coefficients are multivariate polynomials (namely in the \"space\" variables).\n\nNotes\n\nThe parameter N refers to the numerical type of the representation.\n\nIn TMJets, the space variables are normalized to the interval [-1, 1].\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Template-reach-sets-1","page":"Reach-sets","title":"Template reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"TemplateReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.TemplateReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.TemplateReachSet","text":"TemplateReachSet{N, VN, TN<:AbstractDirections{N, VN}, SN<:AbstractVector{N}} <: AbstractLazyReachSet{N}\n\nReach set that stores the support function of a set at a give set of directions.\n\nNotes\n\nThe struct has the following parameters:\n\nN  – refers to the numerical type of the representation.\nVN – refers to the vector type of the template\nTN – refers to the template type\nSN – vector type that holds the support function evaluations\n\nConcrete subtypes of AbstractDirections are defined in the LazySets library.\n\nThis reach-set implicitly represents a set by a set of directions and support functions. set(R::TemplateReachSet) returns a polyhedron in half-space representation.\n\nApart from the getter functions inherited from the AbstractReachSet interface, the following methods are available:\n\ndirections(R)  – return the set of directions normal to the faces of this reach-set\nsup_func(R)    – return the vector of support function evaluations\nsup_func(R, i) – return the i-th coordinate of the vector of support function evaluatons\n\n\n\n\n\n","category":"type"},{"location":"man/hybrid/#Hybrid-systems-1","page":"Hybrid systems","title":"Hybrid systems","text":"","category":"section"},{"location":"man/hybrid/#Introduction-1","page":"Hybrid systems","title":"Introduction","text":"","category":"section"},{"location":"man/hybrid/#","page":"Hybrid systems","title":"Hybrid systems","text":"Our running example is the bouncing ball model; although it is a very hybrid automaton, it can be used to introduce the main notions involved in hybrid systems reachability.","category":"page"},{"location":"man/hybrid/#Clocked-linear-dynamics-1","page":"Hybrid systems","title":"Clocked linear dynamics","text":"","category":"section"},{"location":"man/hybrid/#","page":"Hybrid systems","title":"Hybrid systems","text":"So far we have focused on transitions that involve \"spatial\" variables. If the system under consideration has transitions governed by time variables, i.e. by variables whose dynamics are of the form t = 1, then decoupling the spatial variables with the clock variables gives a computational advantage. We refer to [[HG19]].","category":"page"},{"location":"lib/algorithms/INT/#","page":"INT","title":"INT","text":"INT","category":"page"},{"location":"lib/algorithms/INT/#ReachabilityAnalysis.INT","page":"INT","title":"ReachabilityAnalysis.INT","text":"INT{N, AM} <: AbstractContinuousPost\n\nImplementation of a reachability method for linear one-dimensional systems interval arithmetic.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\n\nThe default approximation model used in this algorithm is:\n\nForward(sih=:concrete, exp=:base, setops=:Interval)\n\nIn particular, the setops=:Interval flag specifies that intermediate computations in the discretization are done using interval arithmetic. This allows for some optimizations.\n\nReferences\n\nThis algorithm is essentially a non-decomposed version of the method in [BFFPSV18], using intervals as set representation. For a general introduction we refer to the dissertation [LG09].\n\nRegarding the approximation model, by default we use an adaptation of the method presented in [FRE11].\n\nInterval arithmetic operations are performed using the IntervalArithmetic.jl package. Hence, the results are guaranteed to comply to the IEE754 standard with respect to the floating-point operations using intervals.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"Home","title":"Home","text":"DocTestSetup = :(using ReachabilityAnalysis)","category":"page"},{"location":"#ReachabilityAnalysis.jl-1","page":"Home","title":"ReachabilityAnalysis.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Methods to compute sets of states reachable by dynamical systems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nReachabilityAnalysis is still under development. If you have questions, find a bug, or have ideas for improvements, feel free to open an issue or make a pull request on the project's GitHub page. You can also find us at the JuliaReach gitter channel.","category":"page"},{"location":"#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This library implements reachability analysis methods for systems of ordinary differential equations (ODEs), for both continuous and hybrid dynamical systems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The following types of ODEs are currently supported:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Continuous ODEs with linear dynamics.\nContinuous ODEs with non-linear dynamics.\nHybrid systems with piecewise-affine dynamics.\nHybrid systems with non-linear dynamics.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For hybrid systems, the transitions may be space-triggered or time-triggered (or both).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In all the problems mentioned above, the library can handle uncertainties in the sets of initial states, inputs, or parameter variation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We refer to the Algorithms section for detailed descriptions of the algorithms available, as well as the references to the technical literature.","category":"page"},{"location":"#Application-domains-1","page":"Home","title":"Application domains","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Reachability analysis has applications in diverse domains such as:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Safety verification: Determining whether a system is safe, i.e. to verify if it does not enter into a region of unsafe sets. Typical applications are assessing the critical distance between autonomous vehicles or robots, or critical concentration of chemicals in a reactor.\nValidation of control strategies: Checking if the system trajectories stay in a region around a reference trajectory, or reach a goal region around a setpoint, for any admissible value of the non-deterministic inputs, initial conditions or noise.\nController synthesis: Finding parameter sets of controllers that satisfy safety or performance constraints.\nDeep neural network verification: Providing formal guarantees for the network behavior subject to perturbations in the inputs, e.g. detecting that small changes in an input image do not cause the network o misclassify it.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We refer to the technical literature for further applications.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In Julia v1.0 or later you can install ReachabilityAnalysis from the Pkg REPL (press ] in the Julia REPL to enter the pkg> mode):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add ReachabilityAnalysis","category":"page"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"DocTestSetup = :(using ReachabilityAnalysis)","category":"page"},{"location":"lib/discretize/#Discretization-1","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"Pages = [\"discretize.md\"]\nDepth = 3","category":"page"},{"location":"lib/discretize/#Approximation-models-1","page":"Discretization","title":"Approximation models","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"ReachabilityAnalysis.AbstractApproximationModel","category":"page"},{"location":"lib/discretize/#ReachabilityAnalysis.AbstractApproximationModel","page":"Discretization","title":"ReachabilityAnalysis.AbstractApproximationModel","text":"AbstractApproximationModel\n\nAbstract supertype for all approximation models.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#Discretize-API-1","page":"Discretization","title":"Discretize API","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"TODO: document discretize.","category":"page"},{"location":"lib/discretize/#Exponentiation-1","page":"Discretization","title":"Exponentiation","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"ReachabilityAnalysis._exp\nReachabilityAnalysis.Φ₁\nReachabilityAnalysis.Φ₂","category":"page"},{"location":"lib/discretize/#ReachabilityAnalysis._exp","page":"Discretization","title":"ReachabilityAnalysis._exp","text":"_exp(A::AbstractMatrix, δ, method)\n\nCompute the matrix exponential e^Aδ.\n\nInput\n\nA       – matrix\nδ       – step size\nmethod  – the method used to take the matrix exponential of A;              possible options are:\n:base – use the scaling and squaring method implemented in Julia standard            library; see ?exp for details\n:lazy – return a lazy wrapper type around the matrix exponential using            the implementation LazySets.SparseMatrixExp\n:pade – apply Pade approximant method to compute the matrix exponential            of a sparse matrix (requires Expokit)\n\nOutput\n\nA matrix or a lazy wrapper of the matrix exponential, depending on method.\n\nNotes\n\nIf the algorithm \"lazy\" is used, evaluations of the action of the matrix exponential are done with the expmv implementation from Expokit (but see LazySets#1312 for the planned generalization to other backends).\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Φ₁","page":"Discretization","title":"ReachabilityAnalysis.Φ₁","text":"Φ₁(A, δ, method)\n\nCompute the series\n\nΦ₁(A δ) = _i=0^ dfracδ^i+1(i+1)A^i\n\nwhere A is a square matrix of order n and δ  mathbbR_0.\n\nInput\n\nA      – coefficient matrix\nδ      – step size\nmethod – (optional, default: \"base\") the method used to take the matrix             exponential of the coefficient matrix; see the documentation of             _exp_Aδ for available options\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nIf A is invertible, Φ₁ can be computed as\n\nΦ₁(A δ) = A^-1(e^δA - I_n)\n\nwhere I_n is the identity matrix of order n.\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP = exp beginpmatrix\nAδ  δI_n  0 \n0  0      δI_n \n0  0      0\nendpmatrix\n\nIt can be shown that Φ₁(A, δ) = P[1:n, (n+1):2*n]. We refer to [[FRE11]] for details.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Φ₂","page":"Discretization","title":"ReachabilityAnalysis.Φ₂","text":"Φ₂(A::AbstractMatrix, δ, method)\n\nCompute the series\n\nΦ₂(A δ) = _i=0^ dfracδ^i+2(i+2)A^i\n\nwhere A is a square matrix of order n and δ  mathbbR_0.\n\nInput\n\nA      – coefficient matrix\nδ      – step size\nmethod – the method used to take the matrix exponential of A; see the             documentation of _exp_Aδ for available options\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nIf A is invertible, Φ₂ can be computed as\n\nΦ₂(A δ) = A^-2(e^δA - I_n - δA)\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP = exp beginpmatrix\nAδ  δI_n  0 \n0  0  δI_n \n0  0  0\nendpmatrix\n\nIt can be shown that Φ₂(A, δ) = P[1:n, (2*n+1):3*n]. We refer to [[FRE11]] for details.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"Let A  mathbbR^nn and for t  0 consider the integral int_0^t e^Aξdξ. If A is invertible, this integral (...)","category":"page"},{"location":"lib/algorithms/BFFPSV18/#BFFPSV18-1","page":"BFFPSV18","title":"BFFPSV18","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"BFFPSV18","category":"page"},{"location":"lib/algorithms/BFFPSV18/#ReachabilityAnalysis.BFFPSV18","page":"BFFPSV18","title":"ReachabilityAnalysis.BFFPSV18","text":"BFFPSV18{N, ST, AM, IDX, BLK, RBLK, CBLK, PT} <: AbstractContinuousPost\n\nImplementation of reachability method for linear systems using block decompositions.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\ndim          – (optional default: missing) ambient dimension\nTODO: fix\n\nNotes\n\nThe type fields are:\n\nN         – number type of the step-size\nAM        – approximation model\nTODO: fix\n\nThe default approximation model is:\n\nForward(sih=:concrete, exp=:base, setops=:lazy)\n\nThis algorithm solves the set-based recurrence equation X_k+1 = ΦX_k  V_k by using block decompositions. The algorithm was introduced in [BFFPSV18].\n\nReferences\n\nThis algorithm is essentially an extension of the method in [BFFPSV18]. Blocks can have different dimensions and the set represenation can be different for each block.\n\nFor a general introduction we refer to the dissertation [SCHI18].\n\nRegarding the approximation model, by default we use an adaptation of the method presented in [FRE11].\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/BFFPSV18/#Reachable-states-approximation-1","page":"BFFPSV18","title":"Reachable states approximation","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"In a nutshell, we overapproximate the reachable states of an affine system by solving a set-based recurrence. The key idea is that we first decompose the system into (low-dimensional) subsystems and later compose the results as a Cartesian product. Thus we have to solve many cheap problems instead of one hard problem. Since solving the recurrence scales superlinearly with the dimension, this approach is very scalable.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Decomposition-error-1","page":"BFFPSV18","title":"Decomposition error","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"Decomposition typically involves a loss in precision, and so does this approach. The good thing is that we can decompose the recurrence as well, which allows us to analyze each of the subsystems independently by only referring to the initial states of the other subsystems. Consequently, there are two main sources for precision loss:","category":"page"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"Decomposition of the initial states: If two subsystems are interdependent initially.\nRepresentation of the reachable states as a Cartesian product: If two subsystems are interdependent in the dynamics.\nRepresentation of the reachable states in general: The reachable states of affine systems cannot be represented precisely in all cases. This is a problem that all approaches suffer from. We overapproximate the reachable states by (unions of) convex polytopes.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Checking-safety-properties-1","page":"BFFPSV18","title":"Checking safety properties","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"The problem of checking a safety property can be reduced to a reachability problem. We provide special support for this reduction by inlining the property check into the reachable states computation. This has two benefits:","category":"page"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"We fail fast when the property is violated in our abstraction.\nThe check is usually cheaper than computing the full reachable states. This is because we are often only interested in an upper or lower bound of a variable.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Lazy-sets-1","page":"BFFPSV18","title":"Lazy sets","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"To represent sets of states, we use the LazySets package which provides exact but lazy (i.e. symbolic) representations of common sets.","category":"page"}]
}
