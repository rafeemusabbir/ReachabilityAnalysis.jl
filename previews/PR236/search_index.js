var documenterSearchIndex = {"docs":
[{"location":"man/setrep/#Set-representations-1","page":"Set representations","title":"Set representations","text":"","category":"section"},{"location":"man/setrep/#Reach-sets-1","page":"Set representations","title":"Reach-sets","text":"","category":"section"},{"location":"man/setrep/#Flowpipes-1","page":"Set representations","title":"Flowpipes","text":"","category":"section"},{"location":"references/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"This page includes references to the scientific works that we have applied throughout this library. Although the list is not meant to be exhaustive, we think it should give a solid starting place for those who want to explore further.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"If you use ReachabilityAnalysis.jl for your own work, please consider citing the appropriate original reference(s). For this purpose we provide the BibTeX citation in each case.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"If you find that a reference here is missing, if you spot a typo or want to update a reference, do not hesitate to contact us by email, or open an issue. Sorting is alphabetic.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ALU95]-1","page":"References","title":"[ALU95]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Alur, R., Courcoubetis, C., Halbwachs, N., Henzinger, T. A., Ho, P. H., Nicollin, X., ... & Yovine, S. (1995). The algorithmic analysis of hybrid systems. Theoretical computer science, 138(1), 3-34.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@article{alur1995algorithmic,\n  title={The algorithmic analysis of hybrid systems},\n  author={Alur, Rajeev and Courcoubetis, Costas and Halbwachs, Nicolas and Henzinger, Thomas A and Ho, Pei-Hsin and Nicollin, Xavier and Olivero, Alfredo and Sifakis, Joseph and Yovine, Sergio},\n  journal={Theoretical computer science},\n  volume={138},\n  number={1},\n  pages={3--34},\n  year={1995},\n  publisher={Citeseer}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ALT10]-1","page":"References","title":"[ALT10]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Althoff, Matthias. Reachability analysis and its application to the safety assessment of autonomous cars. Diss. Technische Universität München, 2010.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{althoff2010reachability,\n  title={Reachability analysis and its application to the safety assessment of autonomous cars},\n  author={Althoff, Matthias},\n  year={2010},\n  school={Technische Universit{\\\"a}t M{\\\"u}nchen}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ASB07]-1","page":"References","title":"[ASB07]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"M. Althoff, O. Stursberg, and M. Buss. Reachability analysis of linear systems with uncertain parameters and inputs. In Proc. of the 46th IEEE Conference on Decision and Control, pages 726–732, 2007.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{althoff2007reachability,\n  title={Reachability analysis of linear systems with uncertain parameters and inputs},\n  author={Althoff, Matthias and Stursberg, Olaf and Buss, Martin},\n  booktitle={2007 46th IEEE Conference on Decision and Control},\n  pages={726--732},\n  year={2007},\n  organization={IEEE}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[BFFPSV18]-1","page":"References","title":"[BFFPSV18]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Bogomolov, S., Forets, M., Frehse, G., Viry, F., Podelski, A., & Schilling, C. (2018, April). Reach set approximation through decomposition with low-dimensional sets and high-dimensional matrices. In Proceedings of the 21st International Conference on Hybrid Systems: Computation and Control (part of CPS Week) (pp. 41-50).","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{bogomolov2018reach,\n  title={Reach set approximation through decomposition with low-dimensional sets and high-dimensional matrices},\n  author={Bogomolov, Sergiy and Forets, Marcelo and Frehse, Goran and Viry, Fr{\\'e}d{\\'e}ric and Podelski, Andreas and Schilling, Christian},\n  booktitle={Proceedings of the 21st International Conference on Hybrid Systems: Computation and Control (part of CPS Week)},\n  pages={41--50},\n  year={2018}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[CHEN15]-1","page":"References","title":"[CHEN15]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Chen, Xin. Reachability Analysis of Non-Linear Hybrid Systems Using Taylor Models. Diss. Fachgruppe Informatik, RWTH Aachen University, 2015.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{chen2015reachability,\n  title={Reachability Analysis of Non-Linear Hybrid Systems Using Taylor Models},\n  author={Chen, Xin},\n  year={2015},\n  school={Fachgruppe Informatik, RWTH Aachen University}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[COMB03]-1","page":"References","title":"[COMB03]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Combastel, C. A state bounding observer based on zonotopes. 2003 European Control Conference (ECC). IEEE, 2003.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{combastel2003state,\n  title={A state bounding observer based on zonotopes},\n  author={Combastel, C},\n  booktitle={2003 European Control Conference (ECC)},\n  pages={2589--2594},\n  year={2003},\n  organization={IEEE}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[FRE11]-1","page":"References","title":"[FRE11]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Frehse, G., Le Guernic, C., Donzé, A., Cotton, S., Ray, R., Lebeltel, O., ... & Maler, O. (2011, July). SpaceEx: Scalable verification of hybrid systems. In International Conference on Computer Aided Verification (pp. 379-395). Springer, Berlin, Heidelberg.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{frehse2011spaceex,\n  title={SpaceEx: Scalable verification of hybrid systems},\n  author={Frehse, Goran and Le Guernic, Colas and Donz{\\'e}, Alexandre and Cotton, Scott and Ray, Rajarshi and Lebeltel, Olivier and Ripado, Rodolfo and Girard, Antoine and Dang, Thao and Maler, Oded},\n  booktitle={International Conference on Computer Aided Verification},\n  pages={379--395},\n  year={2011},\n  organization={Springer}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[FRE16]-1","page":"References","title":"[FRE16]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Frehse, G. (2016). Scalable verification of hybrid systems. (Habilitation á diriger des recherches, Univ. Grenoble Alpes).","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{frehse2016scalable,\n  title={Scalable verification of hybrid systems},\n  author={Frehse, Goran},\n  year={2016}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[FR12]-1","page":"References","title":"[FR12]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Frehse, Goran, and Rajarshi Ray. Flowpipe-Guard Intersection for Reachability Computations with Support Functions. ADHS. 2012.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{frehse2012flowpipe,\n  title={Flowpipe-Guard Intersection for Reachability Computations with Support Functions.},\n  author={Frehse, Goran and Ray, Rajarshi},\n  booktitle={ADHS},\n  pages={94--101},\n  year={2012}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[GIR04]-1","page":"References","title":"[GIR04]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Girard, Antoine. Analyse algorithmique des systemes hybrides. Diss. Institut National Polytechnique de Grenoble-INPG, 2004.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{girard2004analyse,\n  title={Analyse algorithmique des systemes hybrides},\n  author={Girard, Antoine},\n  year={2004},\n  school={Institut National Polytechnique de Grenoble-INPG}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[GIR05]-1","page":"References","title":"[GIR05]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Girard, A. (2005, March). Reachability of uncertain linear systems using zonotopes. In International Workshop on Hybrid Systems: Computation and Control (pp. 291-305). Springer, Berlin, Heidelberg.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{girard2005reachability,\n  title={Reachability of uncertain linear systems using zonotopes},\n  author={Girard, Antoine},\n  booktitle={International Workshop on Hybrid Systems: Computation and Control},\n  pages={291--305},\n  year={2005},\n  organization={Springer}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[GIR13]-1","page":"References","title":"[GIR13]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Girard, Antoine. Computational approaches to analysis and control of hybrid systems. Diss. 2013.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{girard2013computational,\n  title={Computational approaches to analysis and control of hybrid systems},\n  author={Girard, Antoine},\n  year={2013}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[GLGM06]-1","page":"References","title":"[GLGM06]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Girard, A., Le Guernic, C., & Maler, O. (2006, March). Efficient computation of reachable sets of linear time-invariant systems with inputs. In International Workshop on Hybrid Systems: Computation and Control (pp. 257-271). Springer, Berlin, Heidelberg.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{girard2006efficient,\n  title={Efficient computation of reachable sets of linear time-invariant systems with inputs},\n  author={Girard, Antoine and Le Guernic, Colas and Maler, Oded},\n  booktitle={International Workshop on Hybrid Systems: Computation and Control},\n  pages={257--271},\n  year={2006},\n  organization={Springer}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[HG19]-1","page":"References","title":"[HG19]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"el Hakim, Viktorio S., and Marco JG Bekooij. Reachability Analysis of Hybrid Automata with Clocked Linear Dynamics. Proceedings of the 22nd International Workshop on Software and Compilers for Embedded Systems. 2019.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{el2019reachability,\n  title={Reachability Analysis of Hybrid Automata with Clocked Linear Dynamics},\n  author={el Hakim, Viktorio S and Bekooij, Marco JG},\n  booktitle={Proceedings of the 22nd International Workshop on Software and Compilers for Embedded Systems},\n  pages={27--36},\n  year={2019}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[JOL]-1","page":"References","title":"[JOL]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Joldes, M. M. (2011). Approximations polynomiales rigoureuses et applications. (Doctoral dissertation, Lyon, École normale supérieure).","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{joldes2011approximations,\n  title={Approximations polynomiales rigoureuses et applications},\n  author={Joldes, Mioara Maria},\n  year={2011},\n  school={Lyon, {\\'E}cole normale sup{\\'e}rieure}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[KEK18]-1","page":"References","title":"[KEK18]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Kekatos, Nikolaos. Vérification formelle des systèmes cyber-physiques dans le processus industriel de la conception basée sur modèle. Diss. Grenoble Alpes, 2018.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{kekatos2018verification,\n  title={V{\\'e}rification formelle des syst{\\`e}mes cyber-physiques dans le processus industriel de la conception bas{\\'e}e sur mod{\\`e}le},\n  author={Kekatos, Nikolaos},\n  year={2018},\n  school={Grenoble Alpes}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[LGG09]-1","page":"References","title":"[LGG09]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Le Guernic, Colas, and Antoine Girard. Reachability analysis of linear systems using support functions. Nonlinear Analysis: Hybrid Systems 4.2 (2010): 250-262.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@article{le2010reachability,\n  title={Reachability analysis of linear systems using support functions},\n  author={Le Guernic, Colas and Girard, Antoine},\n  journal={Nonlinear Analysis: Hybrid Systems},\n  volume={4},\n  number={2},\n  pages={250--262},\n  year={2010},\n  publisher={Elsevier}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[LGG09b]-1","page":"References","title":"[LGG09b]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Le Guernic, Colas, and Antoine Girard. Reachability analysis of hybrid systems using support functions. International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2009.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@inproceedings{le2009reachability,\n  title={Reachability analysis of hybrid systems using support functions},\n  author={Le Guernic, Colas and Girard, Antoine},\n  booktitle={International Conference on Computer Aided Verification},\n  pages={540--554},\n  year={2009},\n  organization={Springer}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[LG09]-1","page":"References","title":"[LG09]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Le Guernic, Colas. Calcul d’Atteignabilité des Systemes Hybrides a Partie Continue Linéaire. Diss. PhD thesis, Université Grenoble I, 2009.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{le2009calcul,\n  title={Calcul d’Atteignabilit{\\'e} des Systemes Hybrides a Partie Continue Lin{\\'e}aire},\n  author={Le Guernic, Colas},\n  year={2009},\n  school={Citeseer}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[RAY12]-1","page":"References","title":"[RAY12]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Ray, Rajarshi. Calcul d'Atteignabilité des systèmes hybrides avec des fonctions de support. Diss. 2012.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{ray2012calcul,\n  title={Calcul d'Atteignabilit{\\'e} des syst{\\`e}mes hybrides avec des fonctions de support},\n  author={Ray, Rajarshi},\n  year={2012}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[ROC18]-1","page":"References","title":"[ROC18]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Rocca, Alexandre. Formal methods for modelling and validation of biological models. Diss. Grenoble Alpes, 2018.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{rocca2018formal,\n  title={Formal methods for modelling and validation of biological models},\n  author={Rocca, Alexandre},\n  year={2018},\n  school={Grenoble Alpes}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[SCHI18]-1","page":"References","title":"[SCHI18]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Schilling, Christian-Matthias. Fundamental techniques for the scalable analysis of systems. Diss. University of Freiburg, Freiburg im Breisgau, Germany, 2018.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@phdthesis{schilling2018fundamental,\n  title={Fundamental techniques for the scalable analysis of systems.},\n  author={Schilling, Christian-Matthias},\n  year={2018},\n  school={University of Freiburg, Freiburg im Breisgau, Germany}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[SCHU19]-1","page":"References","title":"[SCHU19]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Schupp, Stefan. State set representations and their usage in the reachability analysis of hybrid systems. No. RWTH-2019-08875. Fachgruppe Informatik, 2019.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@techreport{schupp2019state,\n  title={State set representations and their usage in the reachability analysis of hybrid systems},\n  author={Schupp, Stefan},\n  year={2019},\n  institution={Fachgruppe Informatik}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"references/#[YS18]-1","page":"References","title":"[YS18]","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"Yang, Xuejiao, and Joseph K. Scott. A comparison of zonotope order reduction techniques. Automatica 95 (2018): 378-384.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"@article{yang2018comparison,\n  title={A comparison of zonotope order reduction techniques},\n  author={Yang, Xuejiao and Scott, Joseph K},\n  journal={Automatica},\n  volume={95},\n  pages={378--384},\n  year={2018},\n  publisher={Elsevier}\n}","category":"page"},{"location":"references/#","page":"References","title":"References","text":"","category":"page"},{"location":"lib/algorithms/TMJets/#","page":"TMJets","title":"TMJets","text":"TMJets","category":"page"},{"location":"lib/algorithms/TMJets/#ReachabilityAnalysis.TMJets","page":"TMJets","title":"ReachabilityAnalysis.TMJets","text":"TMJets{N, DM<:AbstractDisjointnessMethod} <: AbstractContinuousPost\n\nValidated integration with Taylor models, based on the algorithm implemented by Luis Benet and David Sanders in TalorModels.jl.\n\nFields\n\nmax_steps    – (optional, default: 2000) maximum number of steps in the                   validated integration x = f(x)\nabs_tol      – (optional, default: 1e-10) absolute tolerance\norderT       – (optional, default: 8) order of the Taylor model in time\norderQ       – (optional, default: 2) order of the Taylor models for jet transport variables\ndisjointness – (optional, default: ZonotopeEnclosure()) defines the method to                   perform the disjointness check between the taylor model flowpipe and the invariant\nadaptive     – (optional, default: true) if true, try decreasing the absolute                   tolerance each time step validation fails, until min_abs_tol is reached\nmin_abs_tol  – (optional, default: 1e-29) minimum absolute tolerance for the adaptive algorithm\n\nNotes\n\nThe argument disjointness allows to control how are disjointness checks computed, in the case where the invariant is not universal. In particular, ZonotopeEnclosure() pre-processes the taylor model with a zonotopic overapproximation, then performs the disjointness check with that zonotope and the invariant. For other options, see the documentation of AbstractDisjointnessMethod.\n\n\n\n\n\n","category":"type"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/brusselator.jl\"","category":"page"},{"location":"models/brusselator/#Brusselator-1","page":"Brusselator","title":"Brusselator","text":"","category":"section"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"(Image: )","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"note: Overview\nSystem type: polynomial continuous system\nState dimension: 2\nApplication domain: Chemical kinetics","category":"page"},{"location":"models/brusselator/#Model-description-1","page":"Brusselator","title":"Model description","text":"","category":"section"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"A chemical reaction is said to be autocatalytic if one of the reaction products is also a catalyst for the same or a coupled reaction, and such a reaction is called an autocatalytic reaction. We refer to the wikipedia article Autocatalysis for details.","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"The Brusselator is a mathematical model for a class of autocatalytic reactions. The dynamics of the Brusselator is given by the two-dimensional ODE","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"  left beginarraylcl dotx  =  A + x^2cdot y - Bcdot x - x \n   doty  =  Bcdot x - x^2cdot y endarray right","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"The numerical values for the model's constants (in their respective units) are given in the following table.","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"Quantity Value\nA 1\nB 1.5","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"using ReachabilityAnalysis\n\nconst A = 1.0\nconst B = 1.5\nconst B1 = B + 1\n\n@taylorize function brusselator!(du, u, p, t)\n    x, y = u\n    x² = x * x\n    aux = x² * y\n    du[1] = A + aux - B1*x\n    du[2] = B*x - aux\n    return du\nend","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"note: Performance tip\nThe auxiliary variables B1, x² and aux have been defined to make better use of @taylorize and help to reduce allocations.","category":"page"},{"location":"models/brusselator/#Reachability-settings-1","page":"Brusselator","title":"Reachability settings","text":"","category":"section"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"The initial set is defined by x in 08 1, y in 0 02. These settings are taken from [1].","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"U₀ = (0.8 .. 1.0) × (0.0 .. 0.2);\nprob = @ivp(u' = brusselator!(U), u(0) ∈ U₀, dim: 2);\nnothing #hide","category":"page"},{"location":"models/brusselator/#Results-1","page":"Brusselator","title":"Results","text":"","category":"section"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"We use TMJets algorithm with sixth-order expansion in time and second order expansion in the spatial variables.","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"sol = solve(prob, T=18.0, alg=TMJets(orderT=6, orderQ=2));\nnothing #hide","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"using Plots\n\nsolz = overapproximate(sol, Zonotope)\nplot(solz, vars=(1, 2), xlab=\"x\", ylab=\"y\", lw=0.2, color=:blue, lab=\"Flowpipe\", legend=:bottomright)\nplot!(U₀, color=:orange, lab=\"Uo\")","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"We observe that the system converges to the equilibrium point (1.0, 1.5).","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"Below we plot the flowpipes projected into the time domain.","category":"page"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"plot(solz, vars=(0, 1), xlab=\"t\", lw=0.2, color=:blue, lab=\"x(t)\", legend=:bottomright)\nplot!(solz, vars=(0, 2), xlab=\"t\", lw=0.2, color=:red, lab=\"y(t)\")","category":"page"},{"location":"models/brusselator/#References-1","page":"Brusselator","title":"References","text":"","category":"section"},{"location":"models/brusselator/#","page":"Brusselator","title":"Brusselator","text":"[1] X. Chen, E. Abraham, S. Sankaranarayanan. Flow: An Analyzer for Non-Linear Hybrid Systems.*     In Proceedings of the 25th International Conference on Computer Aided Verification (CAV’13),     Volume 8044 of LNCS, pages 258-263, Springer, 2013.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/transmission_line.jl\"","category":"page"},{"location":"models/transmission_line/#Transmission-line-circuit-1","page":"Transmision line","title":"Transmission line circuit","text":"","category":"section"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"(Image: )","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"note: Overview\nSystem type: linear continuous system\nState dimension: parametric, typically between 4 to 40\nApplication domain: electrical engineering","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"We consider the transmission line model used in [AKS11]. The RLC circuit of the transmission line is shown below. In the circuit, U_in is the voltage at the sending end, and U_out is the voltage at the receiving end.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"<img src=\"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/fig/tline.png?raw=true\" alt=\"Transmission line circuit\" style=\"width: 700px;\"/>","category":"page"},{"location":"models/transmission_line/#Model-description-1","page":"Transmision line","title":"Model description","text":"","category":"section"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"For reference to understand this model we refer to any standard textbook on electrical circuits. The electrical elements law for resistors (R), inductors (L) and capacitors (C) are studied, for instance, in [Chapter 3, K15].","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"Let's assume that the network consists of η  2 nodes. There are η dynamic equations for the capacitor voltages and eta dynamic equations for the circuit currents. Therefore, the state vector can be represented as","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"x = U_1 U_2  U_η I_1 I_2  I_η^T","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"and the state dimension is 2η.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"Analysis of the first node. When writing the equations for the voltages and currents, we should pay attention to the sign choices in given circuit, which do not exactly match the convention in text-books (in the sense that U_1s positive terminal is at the bottom, as indicated by the arrows). Let R_d denote the driver resistance's current. By Kirchhoff's voltage law,","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"U_in = R_d I_1 + LI_1 - U_1","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"therefore","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"boxedI_1 = dfracU_in + U_1L - dfracR_dLI_1","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"By Kirchhoff's current law, and if I_1 C denotes the current through the capacitor C, connected to the first node,","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"   I_1 = I_2 + I_C 1","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"and","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"I_C 1 = -CU_1","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"then","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"   boxedU_1 = fracI_2 - I_1C","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"Analysis of the intermediate nodes. Other node's equations are obtained in a similar fashion. For instance, for the second loop one has","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"-U_1 = RI_2 + LI_2 - U_2 Rightarrow I_2 = dfracU_2-U_1L - fracRLI_2","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"for the current's equation, and","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"   I_2 C = I_2 - I_3Rightarrow U_2 = fracI_3 - I_2C","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"for the voltage's equation.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"Generalizing for arbitrary l = 2 ldots eta - 1 is trivial and gives:","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"    boxedI_l = dfracU_l - U_l-1L - fracRLI_l \n    boxedU_l = dfracI_l+1 - I_lC","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"Analysis of the last node. The last node corresponds to the case l = eta","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"boxedI_eta = dfracU_eta - U_eta-1L - fracRLI_eta \nboxedU_out = U_out = - fracI_etaC","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"System of linear ODEs. Recall that that the stateset is mathbbR^2eta, where the state variables are x = U_1 U_2 ldots U_eta I_1 I_2 ldots I_eta^T. The system can be written as a block-diagonal system of linear ODEs,","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"x(t) = Ax(t) + BU_in(t)","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"using the results in the previous section.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"The coefficients matrix A can be written as a block-diagonal matrix. There exist useful constructors in the base package LinearAlgebra that greatly simplify building matrices with special shape, as in our case, such as diagonal and band matrices, using the types Diagonal and Bidiagonal in our case.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"using ReachabilityAnalysis, LinearAlgebra, SparseArrays\n\nfunction tline(;η=3, R=1.00, Rd=10.0, L=1e-10, C=1e-13 * 4.00)\n    A₁₁ = zeros(η, η)\n    A₁₂ = Bidiagonal(fill(-1/C, η), fill(1/C, η-1), :U)\n    A₂₁ = Bidiagonal(fill(1/L, η), fill(-1/L, η-1), :L)\n    A₂₂ = Diagonal(vcat(-Rd/L, fill(-R/L, η-1)))\n    A  = [A₁₁ A₁₂; A₂₁ A₂₂]\n    B = sparse([η+1], [1], 1/L, 2η, 1)\n    return A, B\nend","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"We can visualize the structure of the cofficients matrix A for the case eta = 20 with spy plot:","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"using Plots\n\nA, _ = tline(η=20)\nspy(A, legend=nothing, markersize=2.0, title=\"Sparsity pattern of A\", xlab=\"columns\", ylab=\"rows\")","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"Notice that the matrix coefficients are rather big, hence it is convenient to rescale the system for numerical stability. Let α  0 be a scaling factor, and let tildex(t) = x(alpha t). By the chain rule,","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"tildex(t) = alpha x(alpha t) = alpha A x(alpha t) + alpha B U_in(alpha t) = tildeA tildex(t) + tildeB tildeU_in(t)","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"where tildeA = alpha A and tildeB = alpha B.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"function scale!(s, α=1.0)\n    s.A .*= α\n    s.B .*= α\n    return s\nend","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"Note that under this transformation, the time horizon has to be transformed as well, through tildeT = alpha T.","category":"page"},{"location":"models/transmission_line/#Reachability-settings-1","page":"Transmision line","title":"Reachability settings","text":"","category":"section"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"The transmission line parameters used in this model are displayed in the following table.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"resistance in [Ω] driver resistance in [Ω] Inductance in [H] Capacitance in [F]\nR = 1.00 Rdriver = 10.0 L = 1e−10 C = 4e−13","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"The steady state is obtained by zeroing the left-hand side of the ODE, which gives","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"   0 = x = Ax_infty + Bu_0 Rightarrow x_infty = -A^-1B u_0","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"The initial set under consideration corresponds to the steady state for input voltages U_in ss = -02 02. Moreover, an uncertainty is added so that the initial currents are also uncertain. The set of initial states is then","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"   x(0) in mathcalX_0 = -A^-1 B  U_in ss oplus (0001)","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"where (ϵ) is the infinity-norm ball of center zero and radius ϵ.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"The time horizon is chosen as T = 07 seconds. We consider a scaling factor alpha = 1e-9.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"We are interested in the step response to an input voltage U_in(t), constant for t in 0 T over the domain U_in = 099 101.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"We consider the case of eta = 20 nodes as in [AKS11], such that the system has n = 40 state variables.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"η = 20 # order\nn = 2η # state-space dimension\nA, B = tline(η=η);\n\nUin_ss = Interval(-0.2, 0.2)\n□(ϵ) = BallInf(zeros(n), ϵ)\nX0 = -inv(Matrix(A)) * B * Uin_ss ⊕ □(0.001);\n\nUin = Interval(0.99, 1.01)\ns = @system(x'= A*x + B*u, x ∈ Universe(n), u ∈ Uin)\nα = 1e-9 # scaling factor\nscale!(s, α);\n\nT = 0.7 * 1e-11 # time horizon\nP = InitialValueProblem(s, X0);\nnothing #hide","category":"page"},{"location":"models/transmission_line/#Results-1","page":"Transmision line","title":"Results","text":"","category":"section"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"We solve system using a step size of δ=1e-3 and the box algorithm.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"sol = solve(P, T=0.7, alg=BOX(δ=1e-3));\nnothing #hide","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"To get the variable U_out we have to project and invert the sign of the η-th coordinate of the flowpipe.","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"Uout = hcat(-1.0) .* project(sol, [η]);\ntimes = [Interval(tspan(R)) for R in sol]\nUout_vs_t = [Δt × u for (Δt, u) in zip(times, Uout)];\nnothing #hide","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"plot(Uout_vs_t, color=:blue, xlab=\"t\", ylab=\"Uout\", alpha=.5, lw=0.5)","category":"page"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"note: Tip\nSince we are only interested in the behavior of U_out, we can use algorithm BFFPSV18 with the options alg=BFFPSV18(δ=1e-3, dim=statedim(P), vars=[η])), which will use an interval (1D) decomposition of the state space and only compute the flowpipe associated with variable eta.","category":"page"},{"location":"models/transmission_line/#Parametric-uncertainties-1","page":"Transmision line","title":"Parametric uncertainties","text":"","category":"section"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"note: TODO\nAdd results with ASB07 and interval parametric uncertainties.","category":"page"},{"location":"models/transmission_line/#References-1","page":"Transmision line","title":"References","text":"","category":"section"},{"location":"models/transmission_line/#","page":"Transmision line","title":"Transmision line","text":"[AKS11] Althoff, Matthias, Bruce H. Krogh, and Olaf Stursberg. Analyzing reachability of linear dynamic systems with parametric uncertainties.. Modeling, Design, and Simulation of Systems with Uncertainties. Springer, Berlin, Heidelberg, 2011. 69-94.\n[K15] Kluever, Craig A. Dynamic systems: modeling, simulation, and control.. John Wiley & Sons, 2015.\n[GLG08] Girard, Antoine, and Colas Le Guernic. Efficient reachability analysis for linear systems using support functions. IFAC Proceedings Volumes 41.2 (2008): 8966-8971.","category":"page"},{"location":"man/linear_high_dim/#Exploiting-structure-1","page":"Exploiting structure","title":"Exploiting structure","text":"","category":"section"},{"location":"man/linear_high_dim/#","page":"Exploiting structure","title":"Exploiting structure","text":"In this section we consider reachability analysis for subsets of variables of a given linear system. Let","category":"page"},{"location":"man/linear_high_dim/#","page":"Exploiting structure","title":"Exploiting structure","text":"x(t) = Ax(t) + v(t)","category":"page"},{"location":"man/linear_high_dim/#","page":"Exploiting structure","title":"Exploiting structure","text":"a = 1\nb = 2\na + b","category":"page"},{"location":"lib/solutions/#","page":"Solutions","title":"Solutions","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/solutions/#Solutions-1","page":"Solutions","title":"Solutions","text":"","category":"section"},{"location":"lib/solutions/#Abstract-interface-1","page":"Solutions","title":"Abstract interface","text":"","category":"section"},{"location":"lib/solutions/#","page":"Solutions","title":"Solutions","text":"ReachabilityAnalysis.AbstractSolution","category":"page"},{"location":"lib/solutions/#ReachabilityAnalysis.AbstractSolution","page":"Solutions","title":"ReachabilityAnalysis.AbstractSolution","text":"AbstractSolution\n\nAbstract supertype of all solution types of a rechability problem.\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#Solution-of-a-reachability-problem-1","page":"Solutions","title":"Solution of a reachability problem","text":"","category":"section"},{"location":"lib/solutions/#","page":"Solutions","title":"Solutions","text":"ReachabilityAnalysis.ReachSolution","category":"page"},{"location":"lib/solutions/#ReachabilityAnalysis.ReachSolution","page":"Solutions","title":"ReachabilityAnalysis.ReachSolution","text":"ReachSolution{FT<:AbstractFlowpipe, ST<:AbstractPost} <: AbstractSolution\n\nType that wraps the solution of a reachability problem as a sequence of lazy sets, and a dictionary of options.\n\nFields\n\nXk       – the list of AbstractReachSets\noptions  – the dictionary of options\n\n\n\n\n\n","category":"type"},{"location":"lib/solutions/#","page":"Solutions","title":"Solutions","text":"TODO: document other methods in solutions.jl.","category":"page"},{"location":"man/applications/epidemic/#","page":"-","title":"-","text":"https://doktormike.gitlab.io/post/covid-19/s","category":"page"},{"location":"about/#About-1","page":"About","title":"About","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"page"},{"location":"about/#Contributing-1","page":"About","title":"Contributing","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"If you like this package, consider contributing! We welcome bug reports, examples that can be added to the documentation, or new feature proposals.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Below we list some conventions that we follow when contributing to this package. For specific guidelines on documentation see the JuliaReach Developer's Documentation.","category":"page"},{"location":"about/#Branches-1","page":"About","title":"Branches","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"Each pull request (PR) should be pushed in a new branch with the name of the author followed by a descriptive name, e.g. mforets/my_feature. If the branch is associated to a previous discussion in an issue, we use the name of the issue for easier lookup, e.g. mforets/7.","category":"page"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)-1","page":"About","title":"Unit testing and continuous integration (CI)","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This project is synchronized with Travis CI, such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to understand and fix the failing tests if they exist. We support Julia v1.0 and develop in the latest stable release. For experimentation we also build on the nightly branch.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"To run the unit tests locally, you should do:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes test/runtests.jl","category":"page"},{"location":"about/#Contributing-to-the-documentation-1","page":"About","title":"Contributing to the documentation","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This documentation is written in Markdown, and it relies on Documenter.jl to produce the HTML layout. To build the documentation, run make.jl:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"lib/algorithms/ASB07/#","page":"ASB07","title":"ASB07","text":"ASB07","category":"page"},{"location":"lib/algorithms/ASB07/#ReachabilityAnalysis.ASB07","page":"ASB07","title":"ReachabilityAnalysis.ASB07","text":"ASB07{N, AM, RM, S, R} <: AbstractContinuousPost\n\nImplementation of Althoff - Stursberg - Buss algorithm for reachability of linear systems with uncertain parameters and inputs using zonotopes.\n\nFields\n\nδ                – step-size of the discretization\napprox_model     – (optional, default: Forward) approximation model;                       see Notes below for possible options\nmax_order        – (optional, default: 5) maximum zonotope order\nreduction_method – (optional, default: GIR05()) zonotope order reduction method used\nstatic           – (optional, default: false) if true, convert the problem data                       to statically sized arrays\nrecursive        – (optional default: true) if true, use the implementation that                       recursively computes each reach-set; otherwise, use the implementation                       that unwraps the sequence until the initial set\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – type of the approximation model\nRM – type associated to the reduction method\nS  – value type associated to the static option\nR  – value type associated to the recursive option\n\nThe sole parameter which doesn't have a default value is the step-size, associated to the type parameter N.\n\nThe default approximation model is\n\napprox_model=CorrectionHull(order=10, exp=:base)\n\nHere, CorrectionHull refers to an implementation of the interval matrix approximation method described in [ASB07]. For technicalities on interval matrix operations, we refer to the package IntervalMatrices.jl.\n\nReferences\n\nThe main ideas behind this algorithm can be found in [ASB07]. These methods are discussed at length in the dissertation [ALT10].\n\nRegarding the zonotope order reduction methods, we refer to [COMB03], [GIR05] and the review article [YS18].\n\n\n\n\n\n","category":"type"},{"location":"man/linear/#Linear-ordinary-differential-equations-1","page":"Linear ODEs","title":"Linear ordinary differential equations","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In this section we show how to solve initial value problems with sets of initial conditions. First we consider the simple scalar equation x(t) = -x(t), where x(0) may be any point in a given initial interval mathcalX_0. Then we consider the spring-mass system, a second order linear ODE studied in introductory physics courses. For that system we show an example of how to compute and project the flowpipe, and then plot the variables of interest.","category":"page"},{"location":"man/linear/#Example-1","page":"Linear ODEs","title":"Example","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Our first example is an initial-value problem for the one-dimensional differential equation","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"x(t) = -x(t)qquad 0  t  T = 40","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"with initial condition x(0)  045 055.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"We can compute the flowpipe using solve:","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"using ReachabilityAnalysis, Plots\n\n# define the initial-value problem\nprob = @ivp(x' = -x, x(0) ∈ 0.45 .. 0.55)\n\n# solve it\nsol = solve(prob, T=4.0)\n\n# plot the solution, where the index 0 corresponds to the \"time\" variable\nplot(sol, vars=(0, 1), label=\"Flowpipe\", xlab=\"t\", ylab=\"x(t)\", linewidth=0.3)","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In practice, analytic solutons of ODEs are unknown. However, in this simple case we know that for an initial point x_0 in mathbbR, the solution is x(t) = x_0 e^-t. We can plot some trajectories in the same plot as the flowpipe, to see that the trajectories are indeed inside the flowpipe, as expected.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"f(t, x0) = x0 * exp(-t)\n\nplot!(t -> f(t, 0.45), xlims=(0, 4), label=\"Analytic sol., x(0) = 0.45\", color=\"red\")\nplot!(t -> f(t, 0.55), xlims=(0, 4), label=\"Analytic sol., x(0) = 0.55\", color=\"red\")","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"This example illustrates that the solution process mainly consists of three steps:","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"(1) Formulating the mathematical problem, in the form of an initial-value problem     with possibly uncertain initial states or inputs.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"(2) Solving the problem, either with the default algorithm or specifying the algorithm     and some of its options.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"(3) Extracting the results, either to visualize with a plot, or to project onto     the relevant variables for further study.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Below we give some further details of this solution step for the simple scalar equation presented above.","category":"page"},{"location":"man/linear/#Problem-formulation-1","page":"Linear ODEs","title":"Problem formulation","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Solution process","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"To illustrate the solution process, we consider a spring-mass system illustrated in the following figure.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"The mass is m and the elastic constant of the spring is k.","category":"page"},{"location":"man/linear/#Solving-the-initial-value-problem-1","page":"Linear ODEs","title":"Solving the initial-value problem","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In this case the system is not given as a set of first-order ODEs, so we will make that transformation as a first step.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Transforming higher-order into a first-order system.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Formulating the mathematical problem involves writing the system as a first-order","category":"page"},{"location":"man/linear/#Analyzing-the-solution-1","page":"Linear ODEs","title":"Analyzing the solution","text":"","category":"section"},{"location":"man/linear/#Spring-mass-system-1","page":"Linear ODEs","title":"Spring-mass system","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In the following example we consider a spring-mass system which is a linear ODE with two-degrees of freedom.","category":"page"},{"location":"man/nonlinear/#Nonlinear-ordinary-differential-equations-1","page":"Nonlinear ODEs","title":"Nonlinear ordinary differential equations","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"In this section we illustrate the flowpipe computation for a nonlinear system.","category":"page"},{"location":"man/nonlinear/#Model-description-1","page":"Nonlinear ODEs","title":"Model description","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Our running example is the Lotka-Volterra model. The 2-dimensional Lotka-Volterra system depicts the populations change of a class of predators and a class of preys. The growth rate of preys’ population x over time is given by","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"dotx = xcdot (alpha - beta cdot y)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"wherein  alpha beta are constant parameters and y is the population of predators.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"It gives that the number of preys grows exponentially without predation.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"The population growth of predators is governed by the differential equation","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"doty = -ycdot (gamma - deltacdot x)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"wherein  gamma delta are constant parameters.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We set those parameters as  alpha = 15   beta = 1   gamma = 3  and  delta = 1.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"using ReachabilityAnalysis\n\n@taylorize function lotka_volterra!(du, u, p, t)\n    local α, β, γ, δ = 1.5, 1.0, 3.0, 1.0\n    du[1] = u[1] * (α - β*u[2])\n    du[2] = -u[2] * (γ - δ*u[1])\n    return du\nend","category":"page"},{"location":"man/nonlinear/#Reachability-settings-1","page":"Nonlinear ODEs","title":"Reachability settings","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"The reachability settings are taken from this resource.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We consider the initial set  xin 4852 y in 1822.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"X₀ = Hyperrectangle(low=[4.8, 1.8], high=[5.2, 2.2])\n\nprob = @ivp(x' = lotka_volterra!(x), dim: 2, x(0) ∈ X₀)","category":"page"},{"location":"man/nonlinear/#Results-1","page":"Nonlinear ODEs","title":"Results","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We compute the flowpipe using the TMJets algorithm for the time horizon 05:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"sol = solve(prob, T=5.0)\n\nsetrep(sol)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"We can change to the zonotopic overapproximation of the flowpipe using the overapproximate function:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"sol = overapproximate(sol, Zonotope)\n\nsetrep(sol)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Finally we plot the solution in phase-space:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"using Plots\n\nplot(sol, vars=(1, 2), xlab=\"x\", ylab=\"y\", lw=0.2, color=:lightblue, lab=\"Flowpipe\")\nplot!(X₀, color=:orange, lab=\"Xo\")","category":"page"},{"location":"man/nonlinear/#Some-common-gotchas-1","page":"Nonlinear ODEs","title":"Some common gotchas","text":"","category":"section"},{"location":"man/nonlinear/#What-is-@taylorize?-Do-I-need-it?-1","page":"Nonlinear ODEs","title":"What is @taylorize? Do I need it?","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"@taylorize is a macro which parses the functions containing the ODEs to be integrated, allowing to speed up repeated evaluations. The macro is defined in TaylorIntegration.jl, see @taylorize's documentation in TaylorIntegration.jl for further details. Since it is an optimization, it is not mandatory, though it is recommended as it helps to reduce the number of allocations and as a consequence it usually gives a performance boost.","category":"page"},{"location":"man/nonlinear/#How-can-I-get-the-most-out-of-@taylorize?-1","page":"Nonlinear ODEs","title":"How can I get the most out of @taylorize?","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"The main advice is to refactor expressions involving several terms into smaller expressions which involve at most two arguments, making appropriate use of parentheses if needed. For further limitations and advice see this section of TaylorInegrations.jl's documentation.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Example. Here is an example that uses some of the above recommendations. Start with f! defined below:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"@taylorize function f!(du, u, params, t)\n    local a = 0.3\n    x, y, z = u[1], u[2], u[3]\n\n    du[1] = -x * y/(1 + x)\n    du[2] = x * y/(1 + x) - a * y\n    du[3] = a * y * y\n    return du\nend","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Observe that the terms x * y can be factored out into a new auxiliary variable aux, and all intermediate operations can be arranged to only involve two arguments, using parentheses:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"@taylorize function g!(du, u, params, t)\n    local a = 0.3\n    x, y, z = u[1], u[2], u[3]\n\n    num = x * y\n    den = 1 + x\n    aux = num/den\n    du[1] = -aux\n    du[2] = aux - a * (y * y)\n    du[3] = a * (y * y)\n    return du\nend","category":"page"},{"location":"man/nonlinear/#Why-do-I-get-an-ArgumentError-when-trying-to-plot-a-solution?-1","page":"Nonlinear ODEs","title":"Why do I get an ArgumentError when trying to plot a solution?","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"For flowpipes computed using algorithm TMJets, the representation is a Taylor model flowpipe, and as such we don't have methods to visualize them exactly. However, to reason about such flowpipes, either for plotting or performing set-based operations, we can overapproximate them with other set representations – usually, convex sets such as boxes or zonotopes–. For instance, the command overapproximate(sol, Zonotope) applies overapproximate(Ri, Zonotope) for each reach-set Ri in the solution sol.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"note: Note\nThe default plotting behavior may change in the future, see discussion in issue #173.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Example. Consider the differential equation x'(t) = x^2(t) - 1, given the interval initial condition [0.4, 0.5]:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"function f!(dx, x, p, t)\n    dx[1] = x[1]^2 - 1.0\nend\nprob = @ivp(x' = f!(x), dim: 1, x(0) ∈ 0.4 .. 0.5)\nsol = solve(prob, T=10.0)","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Trying to plot the solution with the command plot(sol, vars=(1, 2)) will fail with an ArgumentError. However, you can plot the zonotopic overapproximation of this flowpipe:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"solz = overapproximate(sol, Zonotope)\nplot(solz, vars=(0, 1))","category":"page"},{"location":"man/nonlinear/#Equations-with-constant-terms-(BoundsError)-1","page":"Nonlinear ODEs","title":"Equations with constant terms (BoundsError)","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Equations that involve constant terms may give a BoundsError. This is a known bug (cf. issue #179) and it is related to cases in which the update rule for the right-hand side does not have the expected coefficient type. The current solution is to change terms like du[1] = 1.0 into du[1] = 1.0 + zero(u[1]), i.e. let Julia's promotion mechanism take care by adding the given numeric constant with the zero element of the type of u.","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Example. Consider the function f!:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"@taylorize function f!(du, u, p, t)\n    du[1] = u[3]^3 - u[2] + u[4]\n    du[2] = u[3]\n    du[3] = 2.0\n    du[4] = u[4]\n    return du\nend","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"Integrating this function will likely fail with a BoundsError. However, we can re-write it in this way:","category":"page"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"@taylorize function f!(du, u, p, t)\n    local two = 2.0 + zero(u[1])\n    du[1] = u[3]^3 - u[2] + u[4]\n    du[2] = u[3]\n    du[3] = two\n    du[4] = u[4]\n    return du\nend","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"EditURL = \"https://github.com/JuliaReach/ReachabilityAnalysis.jl/blob/master/examples/vanderpol.jl\"","category":"page"},{"location":"models/vanderpol/#Van-der-Pol-oscillator-1","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"","category":"section"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"(Image: )","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"note: Overview\nSystem type: polynomial continuous system\nState dimension: 2\nApplication domain: Nonlinear physics","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"The Van der Pol oscillator was introduced by the Dutch physicist Balthasar van der Pol. This is a famous model, typically investigated in the study of nonlinear dynamics. It has been used in several practical problems of engineering, e.g. circuits containing vacuum tubes. For more information on the model see the wikipedia article Van der Pol oscillator.","category":"page"},{"location":"models/vanderpol/#Dynamics-1","page":"Van der Pol oscillator","title":"Dynamics","text":"","category":"section"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"The dynamics of the Van der Pol oscillator are described by the following ODE with two variables:","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"beginaligned\n  dotx = y \n  doty = mu (1 - x^2) y - x\nendaligned","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"The system has a stable limit cycle. Such limit cycle becomes increasingly sharp for higher values of μ. Here we consider the parameter μ = 1.","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"using ReachabilityAnalysis, Plots\n\n@taylorize function vanderpol!(dx, x, params, t)\n    local μ = 1.0\n    dx[1] = x[2]\n    dx[2] = (μ * x[2]) * (1 - x[1]^2) - x[1]\n    return dx\nend","category":"page"},{"location":"models/vanderpol/#Specification-1","page":"Van der Pol oscillator","title":"Specification","text":"","category":"section"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"We set the initial condition x(0)  125 155, y(0)  235245. The unsafe set is given by y  275 for a time span 0 7. In other words, we would like to prove that there doesn't exist a solution of the model with a y value which is greater than 2.75, for any initial condition on the given domain. Th time horizon of T = 7 is chosen such that the oscillator can do at least one full cycle.","category":"page"},{"location":"models/vanderpol/#Results-1","page":"Van der Pol oscillator","title":"Results","text":"","category":"section"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"We proceed by defining the initial conditions as a hyperrectangular set according to the problem's specifications. Then we build the initial-value problem and pass it to the solve function. We specify using TMJets algorithm with default options.","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"X0 = Hyperrectangle(low=[1.25, 2.35], high=[1.55, 2.45])\nprob = @ivp(x' = vanderpol!(x), dim=2, x(0) ∈ X0)\nsol = solve(prob, T=7.0, alg=TMJets());\nnothing #hide","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"For further computations, it is convenient to work with a zonotopic overapproximation of the flowpipe.","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"solz = overapproximate(sol, Zonotope);\nnothing #hide","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"The maximum value of variable y is obtained by computing the support function of the flowpipe along direction 0 1:","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"ρ([0.0, 1.0], solz)","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"That shows that the property is satisfied. Below we plot the flowpipe in the x-y plane, together with the horizontal line y = 275.","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"plot(solz, vars=(1, 2), lw=0.2, xlims=(-2.5, 2.5), xlab=\"x\", ylab=\"y\")\nplot!(x -> 2.75, color=:red, lab=\"y = 2.75\", style=:dash, legend=:bottomright)","category":"page"},{"location":"models/vanderpol/#Limit-cycle-1","page":"Van der Pol oscillator","title":"Limit cycle","text":"","category":"section"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"We can use the reachability result to examine the limit cycle of the system. In other words, we can see that the flowpipe re-enters from where it started after giving one loop.","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"plot(solz, vars=(1, 2), lw=0.2, xlims=(0.0, 2.5), ylims=(1.6, 2.8), xlab=\"x\", ylab=\"y\")\nplot!(X0, color=:orange, lab=\"X0\")\nplot!(solz[1:5], vars=(1, 2), color=:green, lw=1.0, alpha=0.5, lab=\"F[1:5]\")\nplot!(solz[200], vars=(1, 2), color=:red, lw=1.0, alpha=0.6, lab=\"F[200]\")","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"It is seen that the reach-set corresponding to the time-span","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"tspan(solz[200])","category":"page"},{"location":"models/vanderpol/#","page":"Van der Pol oscillator","title":"Van der Pol oscillator","text":"is included in the set union F1 cup cdots cup F5 of previously computed reach-sets. This in fact constitutes a proof that the system has a limit cycle, because all future trajectories starting from solz[200] are already covered by the flowpipe.","category":"page"},{"location":"lib/algorithms/GLGM06/#","page":"GLGM06","title":"GLGM06","text":"GLGM06","category":"page"},{"location":"lib/algorithms/GLGM06/#ReachabilityAnalysis.GLGM06","page":"GLGM06","title":"ReachabilityAnalysis.GLGM06","text":"GLGM06{N, AM, S, D, NG, P, RM} <: AbstractContinuousPost\n\nImplementation of Girard - Le Guernic - Maler algorithm for reachability of linear systems using zonotopes.\n\nFields\n\nδ                – step-size of the discretization\napprox_model     – (optional, default: Forward) approximation model;                       see Notes below for possible options\nmax_order        – (optional, default: 5) maximum zonotope order\nstatic           – (optional, default: false) if true, convert the problem data                       to statically sized arrays\ndim              – (optional default: missing) ambient dimension\nngens            – (optional, default: missing) number of generators\npreallocate      – (optional, default: true) if true, use the implementation                       which preallocates the zonotopes prior to applying the update rule\nreduction_method    – (optional, default: GIR05()) zonotope order reduction method used\ndisjointness_method – (optional, default: NoEnclosure()) method to check                          disjointness between the reach-set and the invariant\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\nS  – value type associated to the static option\nD  – value type associated to the dimension of the system\nNG – value type associated to the number of generators\nP  – value type associated to the preallocate option\nRM – type associated to the reduction method\n\nThe sole parameter which doesn't have a default value is the step-size, associated to the type parameter N. Parameters D and NG are optionally specified (default to Missing). These parameters are needed for implementations that require the size of the zonotopes to be known (fixed) at compile time, namely the static=true version of this algorithm. Otherwise, the number of generators is not necessarily fixed.\n\nThe default approximation model is\n\napprox_model=Forward(sih=:concrete, exp=:base, setops=:lazy)\n\nHere, Forward refers to the forward-time adaptation of the approximation model from Lemma 3 in [FRE11]. Some of the options to compute this approximation can be specified, see the documentation of Forward for details.\n\nReferences\n\nThe main ideas behind this algorithm can be found in [GIR05] and [GLGM06]. These methods are discussed at length in the dissertation [LG09].\n\nRegarding the zonotope order reduction methods, we refer to [COMB03], [GIR05] and the review article [YS18].\n\nRegarding the approximation model, we use an adaptation of a result in [FRE11].\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/LGG09/#","page":"LGG09","title":"LGG09","text":"LGG09","category":"page"},{"location":"lib/algorithms/LGG09/#ReachabilityAnalysis.LGG09","page":"LGG09","title":"ReachabilityAnalysis.LGG09","text":"LGG09{N, AM, TN<:AbstractDirections} <: AbstractContinuousPost\n\nImplementation of Girard - Le Guernic algorithm for reachability analysis using support functions.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\ntemplate     – struct that holds the directions (either lazily or concretely)                   for each support function evaluation defining the template\nstatic       – (optional, default: false) if true, use statically sized arrays\nthreaded     – (optional, default: true) if true, use multi-threading parallelism                   to compute the support function along each direction\nsparse       – (optional, default: false) if true, convert the matrix exponential                   obtained after discretization to a sparse matrix\ncache        – (optional, default: true) if true, use a cache for intermediate                   computations in the set recurrence loop\n\nNotes\n\nThe type fields are:\n\nN        – number type of the step-size\nAM       – type of the approximation model\nTN       – type of the abstract directions that define the template\n\nReferences\n\nThe is an implementation of the algorithm from [LGG09].\n\nThese methods are described at length in the dissertation [LG09].\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/BOX/#","page":"BOX","title":"BOX","text":"BOX","category":"page"},{"location":"lib/algorithms/BOX/#ReachabilityAnalysis.BOX","page":"BOX","title":"ReachabilityAnalysis.BOX","text":"BOX{N, AM, S, D, R} <: AbstractContinuousPost\n\nImplementation of a reachability method for linear systems using box approximations.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\nstatic\ndim          – (optional default: missing) ambient dimension\nrecursive    – (optional default: false) if true, use the implementation that                   recursively computes each reach-set; otherwise, use the implementation                   that unwraps the sequence until the initial set\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\nS  – value type for the static option\nD  – value type for the dimension\nR  – value type for the recursive option\n\nThe default approximation model is:\n\nForward(sih=:concrete, exp=:base, setops=:lazy)\n\nThis algorithm solves the set-based recurrence equation X_k+1 = ΦX_k  V_k by computing a tight hyperrectangular over-approximation of X_k+1 at each step k  mathbbN. The recursive implementation uses the previously computed set X_k to compute X_k+1. However, it is known that this method incurs wrapping effects. The non-recursive implementation instead computes X_k+1 by unwrapping the discrete recurrence until X_0 = Ω₀, at the expense of computing powers of the matrix Φ. These ideas are discussed in [BFFPSV18].\n\nReferences\n\nThis algorithm is essentially a non-decomposed version of the method in [BFFPSV18], using hyperrectangles as set representation. For a general introduction we refer to the dissertation [LG09].\n\nRegarding the approximation model, by default we use an adaptation of the method presented in [FRE11].\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/flowpipes/#Flowpipes-1","page":"Flowpipes","title":"Flowpipes","text":"","category":"section"},{"location":"lib/flowpipes/#Abstract-interface-1","page":"Flowpipes","title":"Abstract interface","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"AbstractFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.AbstractFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.AbstractFlowpipe","text":"AbstractFlowpipe\n\nAbstract type representing a flowpipe.\n\nNotes\n\nA flowpipe is the set union of an array of reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"The following functions are available at the interface level.","category":"page"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"basetype(::Type{<:AbstractFlowpipe})\nLazySets.ρ(::AbstractVector, ::AbstractFlowpipe)\nLazySets.σ(::AbstractVector, ::AbstractFlowpipe)\nLazySets.dim(::AbstractFlowpipe)\nset(::AbstractFlowpipe, ::Integer)\ntstart(::AbstractFlowpipe)\ntend(::AbstractFlowpipe)\ntspan(::AbstractFlowpipe)","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.basetype-Tuple{Type{#s28} where #s28<:ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.basetype","text":"basetype(T::Type{<:AbstractFlowpipe})\n\nReturn the base type of the given flowpipe type (i.e., without type parameters).\n\nInput\n\nT – flowpipe type, used for dispatch\n\nOutput\n\nThe base type of T.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.ρ-Tuple{AbstractArray{T,1} where T,ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.ρ","text":"LazySets.ρ(d::AbstractVector, fp::AbstractFlowpipe)\n\nInput\n\nd  – direction\nfp – flowpipe\n\nOutput\n\nThe support function of the flowpipe along the given direction d.\n\nNotes\n\nIn this fallback implementation, the flowpipe behaves like the union of the reach-sets, i.e. the implementation is analogue to that of a LazySet.UnionSetArray.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.σ-Tuple{AbstractArray{T,1} where T,ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.σ","text":"LazySets.σ(d::AbstractVector, fp::AbstractFlowpipe)\n\nInput\n\nd  – direction\nfp – flowpipe\n\nOutput\n\nThe support vector of the flowpipe along the given direction d.\n\nNotes\n\nIn this fallback implementation, the flowpipe behaves like the union of the reach-sets, i.e. the implementation is analogue to that of a LazySet.UnionSetArray.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#LazySets.dim-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"LazySets.dim","text":"LazySets.dim(fp::AbstractFlowpipe)\n\nInput\n\nfp – flowpipe\n\nOutput\n\nAn integer representing the ambient dimension of the flowpipe.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.set-Tuple{ReachabilityAnalysis.AbstractFlowpipe,Integer}","page":"Flowpipes","title":"ReachabilityAnalysis.set","text":"set(fp::AbstractFlowpipe, ind::Integer)\n\nReturn the geometric set represented by this flowpipe at the given index.\n\nInput\n\nfp  – flowpipe\nind – index (from 1 to length(flowpipe))\n\nOutput\n\nThe set wrapped by the flowpipe at the given index.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tstart-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tstart","text":"tstart(fp::AbstractFlowpipe)\n\nReturn the initial time of this flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nA float representing the initial time of the given flowpipe. The fallback is computed by taking the initial time of the first reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tend-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tend","text":"tend(fp::AbstractFlowpipe)\n\nReturn the final time of this flowpipe.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the initial time of the given flowpipe. The fallback is computed by taking the final time of the last reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tspan-Tuple{ReachabilityAnalysis.AbstractFlowpipe}","page":"Flowpipes","title":"ReachabilityAnalysis.tspan","text":"tspan(fp::AbstractFlowpipe)\n\nReturn time span of this flowpipe.\n\nInput\n\nfp – flowpipe\n\nOutput\n\nThe interval representing the time span of the given flowpipe. The fallback is computed as (tstart(fp), tend(fp)), see tstart(::AbstractFlowpipe) and tend(::AbstractFlowpipe) for details.\n\n\n\n\n\n","category":"method"},{"location":"lib/flowpipes/#Flowpipe-1","page":"Flowpipes","title":"Flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"Flowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.Flowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.Flowpipe","text":"Flowpipe{N, RT<:AbstractReachSet{N}, VRT<:AbstractVector{RT}} <: AbstractFlowpipe\n\nType that wraps a flowpipe.\n\nFields\n\nXk  – set\next – extension dictionary; field used by extensions\n\nNotes\n\nThe dimension of the flowpipe corresponds to the dimension of the underlying reach-sets; in this type, it is is assumed that the dimension is the same for the different reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"The following methods are available.","category":"page"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"shift","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.shift","page":"Flowpipes","title":"ReachabilityAnalysis.shift","text":"shift(R::AbstractReachSet, t0::Number)\n\nPerform a time-shift of the given reach-set.\n\nInput\n\nR  – reach-set\nt0 – number that corresponds to the time-shift\n\nOutput\n\nA new reach-set of the same type of R such that its time-span has been shifted by t0.\n\n\n\n\n\nshift(fp::Flowpipe{N, ReachSet{N, ST}}, t0::Number) where {N, ST}\n\nReturn the time-shifted flowpipe by the given number.\n\nInput\n\nfp – flowpipe\nt0 – time shift\n\nOutput\n\nA new flowpipe such that the time-span of each constituent reach-set has been shifted by t0.\n\nNotes\n\nSee also Shift for the lazy counterpart.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#Hybrid-flowpipe-1","page":"Flowpipes","title":"Hybrid flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"HybridFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.HybridFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.HybridFlowpipe","text":"HybridFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of the same type, such that they are contiguous in time.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\nThis type assumes that the flowpipes are contiguous in time. This means that the final time the i-th flowpipe matches the start time of the i+1-th flowpipe.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Mixed-flowpipe-1","page":"Flowpipes","title":"Mixed flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"MixedFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.MixedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.MixedFlowpipe","text":"MixedFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of the same time, such that they are not necessarily contiguous in time.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\nThis type does not assume that the flowpipes are contiguous in time.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Shifted-flowpipe-1","page":"Flowpipes","title":"Shifted flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"ShiftedFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.ShiftedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.ShiftedFlowpipe","text":"ShiftedFlowpipe{FT<:AbstractFlowpipe, NT<:Number} <: AbstractFlowpipe\n\nType that lazily represents a flowpipe that has been shifted in time.\n\nFields\n\nF  – original flowpipe\nt0 – time shift\n\nNotes\n\nThis type can wrap any concrete subtype of AbstractFlowpipe, and the extra field t0 is such that the time spans of each reach-set in F are shifted by the amount t0 (which should be a subtype of Number).\n\nA convenience constructor alias Shift is given.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Partitioned-flowpipe-1","page":"Flowpipes","title":"Partitioned flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"PartitionedFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.PartitionedFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.PartitionedFlowpipe","text":"PartitionedFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of possibly different types.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\n\n\n\n\n","category":"type"},{"location":"man/parametric/#Parametric-reachability-1","page":"Parametric reachability","title":"Parametric reachability","text":"","category":"section"},{"location":"man/parametric/#Theory-1","page":"Parametric reachability","title":"Theory","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"Parametric reachability consist of . . . ","category":"page"},{"location":"man/parametric/#Example-1","page":"Parametric reachability","title":"Example","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"We reconsider the example from Section (REF?), but we add an uncertain parameter α that accounts for the variation in the ...","category":"page"},{"location":"man/parametric/#Spring-mass-system-1","page":"Parametric reachability","title":"Spring-mass system","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"Here we consider variations in the constant k and perform reachability . . . .","category":"page"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"In this section we present two problems related to thermal conduction. The first problem, Heat flow PDE, is a model representing the heat xyz. The second model, Hybrid thermostat model, is","category":"page"},{"location":"man/applications/thermal_conduction/#Heat-flow-PDE-1","page":"-","title":"Heat flow PDE","text":"","category":"section"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"ver uno de los SLICOT benchmarks\nver tambien un paper de Zhi Han","category":"page"},{"location":"man/applications/thermal_conduction/#Hybrid-thermostat-model-1","page":"-","title":"Hybrid thermostat model","text":"","category":"section"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"The system is modeled as a two-mode hybrid automaton.","category":"page"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"este ya lo tenemos\nver la referencia","category":"page"},{"location":"introduction/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"In simple terms, reachability analysis is concerned with studying the sets of states that a system can reach, starting from a set of initial states and under the influence of a set of input trajectories and parameter values. More technically, we define the reachable set at a given time point delta in mathbbR, also known as the reach-set for the ODE","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"x(t) = f(x(t) u(t) p(t) t)","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"as given by","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"mathcalR(δ) = left x(δ) = int_0^δ f(x(t) u(t) p(t) t) dt x(0)  X_0 u(t)  mathcalU p(t)  mathcalP right","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Here X_0 denotes the set of initial states, mathcalU denotes the input set, and mathcalP denotes the parameter values. For practical problems, the set mathcalR(δ) cannot be obtained exactly, and reachability methods aim at computing suitable over-approximations (or under-approximations) of it.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"We define the reachable set associated to a time interval 0 δ, also known as the flowpipe, as","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"mathcalF(0 δ) = _t in 0 δ mathcalR(t)","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Reachability methods are used to compute rigorous approximations of the flowpipe for continuous or hybrid systems, in bounded time or unbounded time horizon. Here we use the term rigorous in the formal, or mathematical sense, that no solution \"escapes\" the flowpipe, for any trajectory that satisfies the constraints (initial states, inputs, and noise).","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"On the other hand, the amount of computation required depends heavily on the particular problem statement. One notable example is safety verification, which simply stated requires to prove that the flowpipe does not intersect a region of \"bad states\". In this setting, one can often reason about the flowpipe lazily, i.e. without actually computing it in full.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Up to now we have discussed about the continuous case only, but there is a rich literature in hybrid systems reachability; hybrid here means those dynamical systems which are given by one or more continuous-time dynamics (often, systems of ODEs in each mode or location) coupled with discrete transitions between continuous modes. In our context it is standard to model these systems using the terminology of hybrid automata, and we also model hybrid systems with such framework in this library. The concept of reach-set, flowpipe and safety verification are naturally extended to hybrid automata, although there is the additional complication that the flowpipe must include the behaviors for all possible transitions between discrete modes that are compatible with the dynamics.","category":"page"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/reachsets/#Reach-sets-1","page":"Reach-sets","title":"Reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#Abstract-interface-1","page":"Reach-sets","title":"Abstract interface","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"AbstractReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractReachSet","text":"AbstractReachSet{N}\n\nAbstract type for all reach-sets types.\n\nNotes\n\nA reach-set is a set representation X associated to a given time span Δt.\n\nIn its simplest form, we represent reach-sets with a struct that wraps the tuple (X, Δt), where X corresponds to a geometric set, eg. a polytope, and Δt is the interval with the time span associated to this reach-set.\n\nThis type is parametric in N. The parameter N represents for the type of numerical coefficient used in the representation (typically, N = Float64).\n\nAlthough concrete subtypes of AbstractReachSet may represent the set X in different ways, or carry additional information as an extra type field, they should all implement the AbstractReachSet interface to enable shared functionality for reach-set types. In particular, each concrete subtype should implement the following methods:\n\nset    – return the geometric set\nsetrep – return the type of the set representation\ntspan  – return the time interval span\ntstart – return the initial time\ntend   – return the final time\ndim    – return ambient dimension of the reach-set\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"The functions are available at the interface level.","category":"page"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"basetype(::Type{<:AbstractReachSet})\nset(::AbstractReachSet)\nsetrep(::AbstractReachSet)\ntspan(::AbstractReachSet)\ntstart(::AbstractReachSet)\ntend(::AbstractReachSet)\ndim(::AbstractReachSet)\ncopy(::AbstractReachSet)\nshift(::AbstractReachSet)","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.basetype-Tuple{Type{#s28} where #s28<:ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.basetype","text":"basetype(T::Type{<:AbstractReachSet})\n\nReturn the base type of the given reach-set type (i.e., without type parameters).\n\nInput\n\nT – reach-set type, used for dispatch\n\nOutput\n\nThe base type of T.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.set-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.set","text":"set(R::AbstractReachSet)\n\nReturn the geometric set represented by this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe set wrapped by the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.setrep-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.setrep","text":"setrep(R::AbstractReachSet)\n\nReturn the type of the set representation of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nType of the set representation of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tspan-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tspan","text":"tspan(R::AbstractReachSet)\n\nReturn time span of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe interval representing the time span of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tstart-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tstart","text":"tstart(R::AbstractReachSet)\n\nReturn the initial time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the initial time of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.tend-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.tend","text":"tend(R::AbstractReachSet)\n\nReturn the final time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the final time of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#LazySets.dim-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"LazySets.dim","text":"dim(R::AbstractReachSet)\n\nReturn the ambient dimension of the reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nAn integer corresponding to the ambient dimension of the given reach-set.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#Base.copy-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"Base.copy","text":"copy(R::AbstractReachSet)\n\nReturn a copy of the given reach-set.\n\nInput\n\nR  – reach-set\n\nOutput\n\nA new reach-set of the sam type and the same field values as R.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#ReachabilityAnalysis.shift-Tuple{ReachabilityAnalysis.AbstractReachSet}","page":"Reach-sets","title":"ReachabilityAnalysis.shift","text":"shift(fp::Flowpipe{N, ReachSet{N, ST}}, t0::Number) where {N, ST}\n\nReturn the time-shifted flowpipe by the given number.\n\nInput\n\nfp – flowpipe\nt0 – time shift\n\nOutput\n\nA new flowpipe such that the time-span of each constituent reach-set has been shifted by t0.\n\nNotes\n\nSee also Shift for the lazy counterpart.\n\n\n\n\n\n","category":"method"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"AbstractLazyReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractLazyReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractLazyReachSet","text":"AbstractLazyReachSet{N} <: AbstractReachSet{N}\n\nAbstract type for all reach-set types that use a LazySet for the underlying set representation.\n\nNotes\n\nAn AbstractLazyReachSet is the interface for reach-sets such that the geometric set is represented by any subtype of LazySet.\n\nThis types implements the LazySets interface, namely support function (ρ), support vector (σ) and ambient dimension (dim) functions. Hence, these functions directly apply to concrete subtypes of an AbstractLazyReachSet. The set wrapped by this type is obtained through set(R).\n\nThe following functions should be implemented by any concrete subtype:\n\nreconstruct – create a new instance of the given reach-set with a different                  set representation but sharing the other fields, i.e. the same                  time span (and the same for other fields, if applicable)\n\nIn addition to the functions inherited from AbstractReachSet, the following are available:\n\nproject  – projection of a reach-set\nshift    – time-shift of a reach-set\nvars     – tuple of integers associated to the variables of the given reach-set\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Reachable-set-1","page":"Reach-sets","title":"Reachable set","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"ReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.ReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.ReachSet","text":"ReachSet{N, ST<:LazySet{N}} <: AbstractLazyReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation.\n\nFields\n\nX  – set\nΔt – time interval\n\nNotes\n\nA ReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype LazySet. For efficiency reasons, ST should be concretely typed.\n\nBy assumption the coordinates in this reach-set are associated to the integers 1, …, n. The function vars returns such tuple.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Sparse-reachable-set-1","page":"Reach-sets","title":"Sparse reachable set","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"SparseReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.SparseReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.SparseReachSet","text":"SparseReachSet{N, ST<:LazySet{N}, D} <: AbstractReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation, together with a tuple of variables associated to this reach-set.\n\nFields\n\nX        – set\nΔt       – time interval\nvars – tuple of variable indices represented by the set X\n\nNotes\n\nA SparseReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype of LazySet (ideally, concrete). Moreover, this type also stores information about the variables (also named coordinates, or by abuse of notation, dimensions) corresponding to the set X.\n\nFor instance in the ambient space n=5, one may have a SparseReachSet whose variables tuple is vars = (4, 5, 6), i.e. representing a three-dimensional projection of the full-dimensional reach-set. In consequence, the dimension of X doesn't match the length of vars, in general\n\nIn this type, the parameter N represents the numerical type of the LazySet (typically, Float64), the type ST represents the set representation used, and D denotes the dimension of this sparse reach set. Note that, in contrast to ReachSet, for SparseReachSet the number of dimensions is part of the type information.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Projections-1","page":"Reach-sets","title":"Projections","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"project","category":"page"},{"location":"lib/reachsets/#LazySets.Approximations.project","page":"Reach-sets","title":"LazySets.Approximations.project","text":"project(S::LazySet{N},\n        block::AbstractVector{Int},\n        [::Nothing=nothing],\n        [n]::Int=dim(S)\n       ) where {N<:Real}\n\nProject a high-dimensional set to a given block by using a concrete linear map.\n\nInput\n\nS       – set\nblock   – block structure - a vector with the dimensions of interest\nnothing – (default: nothing) used for dispatch\nn       – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nA set representing the projection of the set S to block block.\n\nAlgorithm\n\nWe apply the function linear_map.\n\n\n\n\n\nproject(S::LazySet{N},\n        block::AbstractVector{Int},\n        set_type::Type{<:LinearMap},\n        [n]::Int=dim(S)\n       ) where {N<:Real}\n\nProject a high-dimensional set to a given block by using a lazy linear map.\n\nInput\n\nS         – set\nblock     – block structure - a vector with the dimensions of interest\nLinearMap – used for dispatch\nn         – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nA lazy LinearMap representing the projection of the set S to block block.\n\n\n\n\n\nproject(S::LazySet{N},\n        block::AbstractVector{Int},\n        set_type::Type{<:LazySet},\n        [n]::Int=dim(S)\n       ) where {N<:Real}\n\nProject a high-dimensional set to a given block and set type, possibly involving an overapproximation.\n\nInput\n\nS        – set\nblock    – block structure - a vector with the dimensions of interest\nset_type – target set type\nn        – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nA set of type set_type representing an overapproximation of the projection of S.\n\nAlgorithm\n\nProject the set S with M⋅S, where M is the identity matrix in the block\n\ncoordinates and zero otherwise.\n\nOverapproximate the projected lazy set using overapproximate and\n\nset_type.\n\n\n\n\n\nproject(S::LazySet{N},\n        block::AbstractVector{Int},\n        set_type_and_precision::Pair{<:UnionAll, <:Real},\n        [n]::Int=dim(S)\n       ) where {N<:Real}\n\nProject a high-dimensional set to a given block and set type with a certified error bound.\n\nInput\n\nS     – set\nblock – block structure - a vector with the dimensions of interest\nset_type_and_precision – pair (T, ε) of a target set type T and an                             error bound ε for approximation\nn     – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nA set representing the epsilon-close approximation of the projection of S.\n\nNotes\n\nCurrently we only support HPolygon as set type, which implies that the set must be two-dimensional.\n\nAlgorithm\n\nProject the set S with M⋅S, where M is the identity matrix in the block\n\ncoordinates and zero otherwise.\n\nOverapproximate the projected lazy set with the given error bound ε.\n\n\n\n\n\nproject(S::LazySet{N},\n        block::AbstractVector{Int},\n        ε::Real,\n        [n]::Int=dim(S)\n       ) where {N<:Real}\n\nProject a high-dimensional set to a given block and set type with a certified error bound.\n\nInput\n\nS     – set\nblock – block structure - a vector with the dimensions of interest\nε     – error bound for approximation\nn     – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nA set representing the epsilon-close approximation of the projection of S.\n\nAlgorithm\n\nProject the set S with M⋅S, where M is the identity matrix in the block\n\ncoordinates and zero otherwise.\n\nOverapproximate the projected lazy set with the given error bound ε.\n\nThe target set type is chosen automatically.\n\n\n\n\n\nproject(S::LazySet{N},\n        block::AbstractVector{Int},\n        directions::Type{<:AbstractDirections},\n        [n]::Int\n       ) where {N<:Real}\n\nProject a high-dimensional set to a given block using template directions.\n\nInput\n\nS          – set\nblock      – block structure - a vector with the dimensions of interest\ndirections – template directions\nn          – (optional, default: dim(S)) ambient dimension of the set S\n\nOutput\n\nThe template direction approximation of the projection of S.\n\n\n\n\n\nproject(H::HalfSpace{N}, block::AbstractVector{Int})\n\nConcrete projection of a half-space.\n\nInput\n\nH        – set\nblock    – block structure, a vector with the dimensions of interest\n\nOutput\n\nA set representing the projection of the half-space H on the dimensions specified by block.\n\nAlgorithm\n\nIf the unconstrained dimensions of H are a subset of the block variables, the projection is applied to the normal direction of H. Otherwise, the projection results in the universal set.\n\nThe latter can be seen as follows. Without loss of generality consider a projection onto a single and constrained dimension xₖ (projections in multiple dimensions can be modeled as repeated one-dimensional projections). We can write the projection as an existentially quantified linear constraint:\n\n    xₖ a₁x₁ +  + aₖxₖ +  + aₙxₙ  b\n\nSince aₖ  0, there is always a value for xₖ that satisfies the constraint for any valuation of the other variables.\n\nExamples\n\nConsider the half-space x + y + 0z  1, whose ambient dimension is 3. The (trivial) projection in the three dimensions is achieved letting the block of variables to be [1, 2, 3]:\n\njulia> H = HalfSpace([1.0, 1.0, 0.0], 1.0)\nHalfSpace{Float64,Array{Float64,1}}([1.0, 1.0, 0.0], 1.0)\n\njulia> project(H, [1, 2, 3])\nHalfSpace{Float64,Array{Float64,1}}([1.0, 1.0, 0.0], 1.0)\n\nProjecting along dimensions 1 and 2 only:\n\njulia> project(H, [1, 2])\nHalfSpace{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)\n\nIn general, use the call syntax project(H, constrained_dimensions(H)) to return the half-space projected on the dimensions where it is constrained only:\n\njulia> project(H, constrained_dimensions(H))\nHalfSpace{Float64,Array{Float64,1}}([1.0, 1.0], 1.0)\n\nIf a constrained dimension is projected, we get the universal set of the dimension corresponding to the projection.\n\njulia> project(H, [1, 3])\nUniverse{Float64}(2)\n\njulia> project(H, [1])\nUniverse{Float64}(1)\n\n\n\n\n\nproject(P::AbstractPolyhedron{N}, block::AbstractVector{Int}) where {N}\n\nConcrete projection of a polyhedral set.\n\nInput\n\nP        – set\nblock    – block structure, a vector with the dimensions of interest\n\nOutput\n\nAn HPolyhedron representing the projection of P on the dimensions specified by block.\n\nAlgorithm\n\nIf the unconstrained dimensions of P are a subset of the block variables, each half-sace c of P is transformed to HalfSpace(c.a[block], c.b).\nIn the general case, we compute the concrete linear map of the projection matrix associated to the given block structure.\n\nExamples\n\nConsider the four-dimensional cross-polytope (unit ball in the 1-norm):\n\njulia> P = Ball1(zeros(4), 1.0);\n\nAll dimensions are constrained, and computing the (trivial) projection on the whole space behaves as expected:\n\njulia> constrained_dimensions(P)\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> P_1234 = project(P, [1, 2, 3, 4]);\n\njulia> P_1234 == convert(HPolyhedron, P)\ntrue\n\nEach constraint of the cross polytope is constrained in all dimensions.\n\nNow let's take a ball in the infinity norm and remove some constraints:\n\njulia> B = BallInf(zeros(4), 1.0);\n\njulia> c = constraints_list(B)[1:2]\n2-element Array{HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}},1}:\n HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([1.0, 0.0, 0.0, 0.0], 1.0)\n HalfSpace{Float64,LazySets.Arrays.SingleEntryVector{Float64}}([0.0, 1.0, 0.0, 0.0], 1.0)\n\njulia> P = HPolyhedron(c);\n\njulia> constrained_dimensions(P)\n2-element Array{Int64,1}:\n 1\n 2\n\nFinally we take the concrete projection onto variables 1 and 2:\n\njulia> project(P, [1, 2]) |> constraints_list\n2-element Array{HalfSpace{Float64,Array{Float64,1}},1}:\n HalfSpace{Float64,Array{Float64,1}}([1.0, 0.0], 1.0)\n HalfSpace{Float64,Array{Float64,1}}([0.0, 1.0], 1.0)\n\n\n\n\n\nproject(R::AbstractLazyReachSet, variables::NTuple{D, M};\n        check_vars::Bool=true) where {D, M<:Integer}\n\nProjects a reach-set onto the subspace spanned by the given variables.\n\nInput\n\nR          – reach-set\nvars       – tuple of variables for the projection\ncheck_vars – (optional, default: true) if true, check that the given variable                 indices vars are a subset of the variables of R\n\nOutput\n\nA SparseReachSet whose variable indices are given by vars.\n\nThe type of the new reach-set depends on the type of the reach-set R:\n\nIf R contains a hyperrectangular set, the output is a hyperrectangle.\nIf R contains a zonotopic set, the output is a zonotope.\nOtherwise, the return type is a polytope either in constraint representation or in vertex representation, depending on the dimension and the properties of M. For details, see LazySets.project.\n\nNotes\n\nThis function can be used to project a reach-set onto a lower-dimensional sub-space. The projection is concrete, and it consists of mapping the reach-set X = set(R) to a new reach-set through to MX, where M is the projection matrix associated with the given variables vars.\n\nTo project onto the time variable, use the index 0. For instance, (0, 1) projects onto the time variable and the first variable in R.\n\n\n\n\n\n","category":"function"},{"location":"lib/reachsets/#Taylor-model-reach-sets-1","page":"Reach-sets","title":"Taylor model reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"AbstractTaylorModelReachSet\nTaylorModelReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.AbstractTaylorModelReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.AbstractTaylorModelReachSet","text":"AbstractTaylorModelReachSet{N}\n\nAbstract type for all reach sets types that represent a Taylor model.\n\nNotes\n\nThe parameter N refers to the numerical type of the representation.\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#ReachabilityAnalysis.TaylorModelReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.TaylorModelReachSet","text":"TaylorModelReachSet{N} <: AbstractTaylorModelReachSet{N}\n\nTaylor model reach-set represented as a of vector taylor models in one variable (the \"time\" variable) whose coefficients are multivariate polynomials (the \"space\" variables).\n\nNotes\n\nThe parameter N refers to the numerical type of the representation.\n\nIn TMJets, the space variables are normalized to the interval [-1, 1].\n\n\n\n\n\n","category":"type"},{"location":"lib/reachsets/#Template-reach-sets-1","page":"Reach-sets","title":"Template reach-sets","text":"","category":"section"},{"location":"lib/reachsets/#","page":"Reach-sets","title":"Reach-sets","text":"TemplateReachSet","category":"page"},{"location":"lib/reachsets/#ReachabilityAnalysis.TemplateReachSet","page":"Reach-sets","title":"ReachabilityAnalysis.TemplateReachSet","text":"TemplateReachSet{N, VN, TN<:AbstractDirections{N, VN}, SN<:AbstractVector{N}} <: AbstractLazyReachSet{N}\n\nReach set that stores the support function of a set at a give set of directions.\n\nNotes\n\nThe struct has the following parameters:\n\nN  – refers to the numerical type of the representation.\nVN – refers to the vector type of the template\nTN – refers to the template type\nSN – vector type that holds the support function evaluations\n\nConcrete subtypes of AbstractDirections are defined in the LazySets library.\n\nThis reach-set implicitly represents a set by a set of directions and support functions. set(R::TemplateReachSet) returns a polyhedron in half-space representation.\n\nApart from the getter functions inherited from the AbstractReachSet interface, the following methods are available:\n\ndirections(R)  – return the set of directions normal to the faces of this reach-set\nsup_func(R)    – return the vector of support function evaluations\nsup_func(R, i) – return the i-th coordinate of the vector of support function evaluatons\n\n\n\n\n\n","category":"type"},{"location":"man/hybrid/#Hybrid-systems-1","page":"Hybrid systems","title":"Hybrid systems","text":"","category":"section"},{"location":"man/hybrid/#Introduction-1","page":"Hybrid systems","title":"Introduction","text":"","category":"section"},{"location":"man/hybrid/#","page":"Hybrid systems","title":"Hybrid systems","text":"Our running example is the bouncing ball model; although it is a very hybrid automaton, it can be used to introduce the main notions involved in hybrid systems reachability.","category":"page"},{"location":"man/hybrid/#Clocked-linear-dynamics-1","page":"Hybrid systems","title":"Clocked linear dynamics","text":"","category":"section"},{"location":"man/hybrid/#","page":"Hybrid systems","title":"Hybrid systems","text":"So far we have focused on transitions that involve \"spatial\" variables. If the system under consideration has transitions governed by time variables, i.e. by variables whose dynamics are of the form t = 1, then decoupling the spatial variables with the clock variables gives a computational advantage. We refer to [[HG19]].","category":"page"},{"location":"lib/algorithms/INT/#","page":"INT","title":"INT","text":"INT","category":"page"},{"location":"lib/algorithms/INT/#ReachabilityAnalysis.INT","page":"INT","title":"ReachabilityAnalysis.INT","text":"INT{N, AM} <: AbstractContinuousPost\n\nImplementation of a reachability method for linear one-dimensional systems interval arithmetic.\n\nFields\n\nδ            – step-size of the discretization\napprox_model – (optional, default: Forward) approximation model;                   see Notes below for possible options\n\nNotes\n\nThe type fields are:\n\nN  – number type of the step-size\nAM – approximation model\n\nThe default approximation model used in this algorithm is:\n\nForward(sih=:concrete, exp=:base, setops=:Interval)\n\nIn particular, the setops=:Interval flag specifies that intermediate computations in the discretization are done using interval arithmetic. This allows for some optimizations.\n\nReferences\n\nThis algorithm is essentially a non-decomposed version of the method in [BFFPSV18], using intervals as set representation. For a general introduction we refer to the dissertation [LG09].\n\nRegarding the approximation model, by default we use an adaptation of the method presented in [FRE11].\n\nInterval arithmetic operations are performed using the IntervalArithmetic.jl package. Hence, the results are guaranteed to comply to the IEE754 standard with respect to the floating-point operations using intervals.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"Home","title":"Home","text":"DocTestSetup = :(using ReachabilityAnalysis)","category":"page"},{"location":"#ReachabilityAnalysis.jl-1","page":"Home","title":"ReachabilityAnalysis.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Methods to compute sets of states reachable by dynamical systems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nReachabilityAnalysis is still under development. If you have questions, find a bug, or have ideas for improvements, feel free to open an issue or make a pull request on the project's GitHub page. You can also find us at the JuliaReach gitter channel.","category":"page"},{"location":"#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This library implements reachability analysis methods for systems of ordinary differential equations (ODEs), for both continuous and hybrid dynamical systems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The following types of ODEs are currently supported:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Continuous ODEs with linear dynamics.\nContinuous ODEs with non-linear dynamics.\nHybrid systems with piecewise-affine dynamics.\nHybrid systems with non-linear dynamics.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For hybrid systems, the transitions may be space-triggered or time-triggered (or both).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In all the problems mentioned above, the library can handle uncertainties in the sets of initial states, inputs, or parameter variation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We refer to the Algorithms section for detailed descriptions of the algorithms available, as well as the references to the technical literature.","category":"page"},{"location":"#Application-domains-1","page":"Home","title":"Application domains","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Reachability analysis has applications in diverse domains such as:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Safety verification: Determining whether a system is safe, i.e. to verify if it does not enter into a region of unsafe sets. Typical applications are assessing the critical distance between autonomous vehicles or robots, or critical concentration of chemicals in a reactor.\nValidation of control strategies: Checking if the system trajectories stay in a region around a reference trajectory, or reach a goal region around a setpoint, for any admissible value of the non-deterministic inputs, initial conditions or noise.\nController synthesis: Finding parameter sets of controllers that satisfy safety or performance constraints.\nDeep neural network verification: Providing formal guarantees for the network behavior subject to perturbations in the inputs, e.g. detecting that small changes in an input image do not cause the network o misclassify it.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We refer to the technical literature for further applications.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In Julia v1.0 or later you can install ReachabilityAnalysis from the Pkg REPL (press ] in the Julia REPL to enter the pkg> mode):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add ReachabilityAnalysis","category":"page"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"DocTestSetup = :(using ReachabilityAnalysis)","category":"page"},{"location":"lib/discretize/#Discretization-1","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"Pages = [\"discretize.md\"]\nDepth = 3","category":"page"},{"location":"lib/discretize/#Approximation-models-1","page":"Discretization","title":"Approximation models","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"ReachabilityAnalysis.AbstractApproximationModel","category":"page"},{"location":"lib/discretize/#ReachabilityAnalysis.AbstractApproximationModel","page":"Discretization","title":"ReachabilityAnalysis.AbstractApproximationModel","text":"AbstractApproximationModel\n\nAbstract supertype for all approximation models.\n\n\n\n\n\n","category":"type"},{"location":"lib/discretize/#Discretize-API-1","page":"Discretization","title":"Discretize API","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"TODO: document discretize.","category":"page"},{"location":"lib/discretize/#Exponentiation-1","page":"Discretization","title":"Exponentiation","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"ReachabilityAnalysis._exp\nReachabilityAnalysis.Φ₁\nReachabilityAnalysis.Φ₂","category":"page"},{"location":"lib/discretize/#ReachabilityAnalysis._exp","page":"Discretization","title":"ReachabilityAnalysis._exp","text":"_exp(A::AbstractMatrix, δ, method)\n\nCompute the matrix exponential e^Aδ.\n\nInput\n\nA       – matrix\nδ       – step size\nmethod  – the method used to take the matrix exponential of A;              possible options are:\n:base – use the scaling and squaring method implemented in Julia standard            library; see ?exp for details\n:lazy – return a lazy wrapper type around the matrix exponential using            the implementation LazySets.SparseMatrixExp\n:pade – apply Pade approximant method to compute the matrix exponential            of a sparse matrix (requires Expokit)\n\nOutput\n\nA matrix or a lazy wrapper of the matrix exponential, depending on method.\n\nNotes\n\nIf the algorithm \"lazy\" is used, evaluations of the action of the matrix exponential are done with the expmv implementation from Expokit (but see LazySets#1312 for the planned generalization to other backends).\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Φ₁","page":"Discretization","title":"ReachabilityAnalysis.Φ₁","text":"Φ₁(A, δ, method)\n\nCompute the series\n\nΦ₁(A δ) = _i=0^ dfracδ^i+1(i+1)A^i\n\nwhere A is a square matrix of order n and δ  mathbbR_0.\n\nInput\n\nA      – coefficient matrix\nδ      – step size\nmethod – (optional, default: \"base\") the method used to take the matrix             exponential of the coefficient matrix; see the documentation of             _exp_Aδ for available options\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nIf A is invertible, Φ₁ can be computed as\n\nΦ₁(A δ) = A^-1(e^δA - I_n)\n\nwhere I_n is the identity matrix of order n.\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP = exp beginpmatrix\nAδ  δI_n  0 \n0  0      δI_n \n0  0      0\nendpmatrix\n\nIt can be shown that Φ₁(A, δ) = P[1:n, (n+1):2*n]. We refer to [[FRE11]] for details.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Φ₂","page":"Discretization","title":"ReachabilityAnalysis.Φ₂","text":"Φ₂(A::AbstractMatrix, δ, method)\n\nCompute the series\n\nΦ₂(A δ) = _i=0^ dfracδ^i+2(i+2)A^i\n\nwhere A is a square matrix of order n and δ  mathbbR_0.\n\nInput\n\nA      – coefficient matrix\nδ      – step size\nmethod – the method used to take the matrix exponential of A; see the             documentation of _exp_Aδ for available options\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nIf A is invertible, Φ₂ can be computed as\n\nΦ₂(A δ) = A^-2(e^δA - I_n - δA)\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP = exp beginpmatrix\nAδ  δI_n  0 \n0  0  δI_n \n0  0  0\nendpmatrix\n\nIt can be shown that Φ₂(A, δ) = P[1:n, (2*n+1):3*n]. We refer to [[FRE11]] for details.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"Let A  mathbbR^nn and for t  0 consider the integral int_0^t e^Aξdξ. If A is invertible, this integral (...)","category":"page"},{"location":"lib/algorithms/BFFPSV18/#BFFPSV18-1","page":"BFFPSV18","title":"BFFPSV18","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"BFFPSV18","category":"page"},{"location":"lib/algorithms/BFFPSV18/#ReachabilityAnalysis.BFFPSV18","page":"BFFPSV18","title":"ReachabilityAnalysis.BFFPSV18","text":"BFFPSV18{N, ST, AM, IDX, BLK, RBLK, CBLK} <: AbstractContinuousPost\n\nImplementation of the reachability method for linear systems using block decompositions.\n\nFields\n\nδ                – step-size of the discretization\napprox_model     – (optional, default: Forward) approximation model;                       see Notes below for possible options\nvars             – vector with the variables of interest\nblock_indices    – vector of integers to index each block that contains a variable of interest\nrow_blocks       – vector of integer vectors to index variables associated to blocks of interest\ncolumn_blocks    – vector of integer vectors to index variables in the partition\nlazy_initial_set – (optional, default: false) if true, use a lazy decomposition of the initial states                       after discretization\nlazy_input    – (optional, default: false) if true, use a lazy decomposition of the input set                     after discretization\nsparse        – (optional, default: false) if true, assume that the state transition                     matrix is sparse\nview          – (optional, default: false) if true, use implementaton that                    uses arrays views\n\nmatrix is sparse\n\nSee the Examples section below for some concrete examples of these options.\n\nNotes\n\nThis algorithm solves the set-based recurrence equation X_k+1 = ΦX_k  V_k by using block decompositions. The algorithm was introduced in [BFFPSV18].\n\nComments about some fields:\n\nN    – number type of the step-size, e.g. Float64\nST   – set representation used; this is either a concrete LazySet subtype,           eg. Interval{Float64, IntervalArithmetic.Interval{Float64}}, or a tuple           of concrete LazySet subtypes that is commensurate with the partition\n\nThe default approximation model is:\n\nForward(sih=:concrete, exp=:base, setops=:lazy)\n\nTODO:\n\nclarify assumption about contiguous blocks\n\nExamples\n\nReferences\n\nThis algorithm is essentially an extension of the method in [BFFPSV18]. Blocks can have different dimensions and the set represenation can be different for each block.\n\nFor a general introduction we refer to the dissertation [SCHI18].\n\nRegarding the approximation model, by default we use an adaptation of the method presented in [FRE11].\n\n\n\n\n\n","category":"type"},{"location":"lib/algorithms/BFFPSV18/#Reachable-states-approximation-1","page":"BFFPSV18","title":"Reachable states approximation","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"In a nutshell, we overapproximate the reachable states of an affine system by solving a set-based recurrence. The key idea is that we first decompose the system into (low-dimensional) subsystems and later compose the results as a Cartesian product. Thus we have to solve many cheap problems instead of one hard problem. Since solving the recurrence scales superlinearly with the dimension, this approach is very scalable.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Decomposition-error-1","page":"BFFPSV18","title":"Decomposition error","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"Decomposition typically involves a loss in precision, and so does this approach. The good thing is that we can decompose the recurrence as well, which allows us to analyze each of the subsystems independently by only referring to the initial states of the other subsystems. Consequently, there are two main sources for precision loss:","category":"page"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"Decomposition of the initial states: If two subsystems are interdependent initially.\nRepresentation of the reachable states as a Cartesian product: If two subsystems are interdependent in the dynamics.\nRepresentation of the reachable states in general: The reachable states of affine systems cannot be represented precisely in all cases. This is a problem that all approaches suffer from. We overapproximate the reachable states by (unions of) convex polytopes.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Checking-safety-properties-1","page":"BFFPSV18","title":"Checking safety properties","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"The problem of checking a safety property can be reduced to a reachability problem. We provide special support for this reduction by inlining the property check into the reachable states computation. This has two benefits:","category":"page"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"We fail fast when the property is violated in our abstraction.\nThe check is usually cheaper than computing the full reachable states. This is because we are often only interested in an upper or lower bound of a variable.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Lazy-sets-1","page":"BFFPSV18","title":"Lazy sets","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"To represent sets of states, we use the LazySets package which provides exact but lazy (i.e. symbolic) representations of common sets.","category":"page"}]
}
