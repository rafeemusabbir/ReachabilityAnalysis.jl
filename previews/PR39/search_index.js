var documenterSearchIndex = {"docs":
[{"location":"references/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"references/#","page":"References","title":"References","text":"This page includes the original references for each algorithm included in this library. If you use ReachabilityAnalysis.jl for your own work, do consider citing the appropriate original reference.","category":"page"},{"location":"references/#","page":"References","title":"References","text":"[G05] Girard, A. (2005, March). Reachability of uncertain linear systems using       zonotopes.       In International Workshop on Hybrid Systems: Computation and Control (pp. 291-305).       Springer, Berlin, Heidelberg.\n[GLM06] Girard, A., Le Guernic, C., & Maler, O. (2006, March).        Efficient computation of reachable sets of linear time-invariant systems        with inputs.        In International Workshop on Hybrid Systems: Computation and Control (pp. 257-271).        Springer, Berlin, Heidelberg.","category":"page"},{"location":"lib/solution_types/#","page":"Solution types","title":"Solution types","text":"go","category":"page"},{"location":"about/#About-1","page":"About","title":"About","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Pages = [\"about.md\"]","category":"page"},{"location":"about/#Contributing-1","page":"About","title":"Contributing","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"If you like this package, consider contributing! We welcome bug reports, examples that can be added to the documentation, or new feature proposals.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Below some conventions that we follow when contributing to this package are detailed. For specific guidelines on documentation, see the Documentations Guidelines wiki.","category":"page"},{"location":"about/#Branches-1","page":"About","title":"Branches","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"Each pull request (PR) should be pushed in a new branch with the name of the author followed by a descriptive name, e.g. t/mforets/my_feature. If the branch is associated to a previous discussion in one issue, we use the name of the issue for easier lookup, e.g. t/mforets/7.","category":"page"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)-1","page":"About","title":"Unit testing and continuous integration (CI)","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This project is synchronized with Travis CI, such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to understand and fix the failing doctests if they exist. We develop in Julia v0.6.0, but for experimentation we also build on the nightly branch.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"To run the unit tests locally, you should do:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes test/runtests.jl","category":"page"},{"location":"about/#Contributing-to-the-documentation-1","page":"About","title":"Contributing to the documentation","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This documentation is written in Markdown, and it relies on Documenter.jl to produce the HTML layout. To build the docs, run make.jl:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"about/#References-1","page":"About","title":"References","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This repository was originally motivated by the mathematical approach described in Reach Set Approximation through Decomposition with Low-dimensional Sets and High-dimensional Matrices,  Sergiy Bogomolov, Marcelo Forets, Goran Frehse, Andreas Podelski, Christian Schilling, Frédéric Viry, in 21st ACM International Conference on Hybrid Systems: Computation and Control, 2018 Edition (Porto, Portugal), see the arXiv pre-print here.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"For a full references list of algorithms implemented in this repository, consult the References wiki.","category":"page"},{"location":"about/#Developers-1","page":"About","title":"Developers","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"Here we list the names of the contributors to ReachabilityAnalysis.jl (in alphabetic order).","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Marcelo Forets\nDaniel Freire\n[Christian Schilling]http://github.com/schillic)","category":"page"},{"location":"about/#Acknowledgements-1","page":"About","title":"Acknowledgements","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"We are also grateful to the following persons for enlightening discussions:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Sergiy Bogomolov\nGoran Frehse\nNikolaos Kekatos\nAndreas Podelski\nKostiantyn Potomkin\nAlexandre Rocca\nFrederic Viry","category":"page"},{"location":"man/linear/#Linear-ordinary-differential-equations-1","page":"Linear ODEs","title":"Linear ordinary differential equations","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In this section we begin by solving a simple scalar equation. Then we introduce the functionality to solve systems of equations. Finally, we consider a higher-dimensional example and some","category":"page"},{"location":"man/linear/#Example-1","page":"Linear ODEs","title":"Example","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Our first example is the one-dimensional differential equation x(t) = -x over the time interval 0  t  T. Suppose that the initial state can be any point in the interval x(0)  0 1.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"using ReachabilityAnalysis\nP = @ivp x' = -x, x(0) ∈ 0..1\nsol = solve(P)\n\nusing Plots\nplot(sol, label=\"Flowpipe\")","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"The analytic solution for an initial point x_0 is x(t) = e^-tx_0, which is also plotted","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"plot!(, t -> -exp(-t), label=\"Analytic solution\")","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"As we have seen in this example, the solution process mainly consists of three steps:","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"formulating the mathematical problem\nsolving the problem\nextracting the results, eg. plotting, or projecting","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In the following example we consider a higher-dimensional ODE to illustrate in some detail these steps.","category":"page"},{"location":"man/linear/#Solution-process-1","page":"Linear ODEs","title":"Solution process","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"To illustrate the solution process, we consider a spring-mass system illustrated in the following figure.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"The mass is m and the elastic constant of the spring is k.","category":"page"},{"location":"man/linear/#Problem-formulation-1","page":"Linear ODEs","title":"Problem formulation","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"In this case the system is not given as a set of first-order ODEs, so we will make that transformation as a first step.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Transforming higher-order into a first-order system.","category":"page"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"Formulating the mathematical problem involves writing the system as a first-order","category":"page"},{"location":"man/linear/#Solving-the-problem-1","page":"Linear ODEs","title":"Solving the problem","text":"","category":"section"},{"location":"man/linear/#Extracting-the-results,-eg.-plotting,-or-projecting-1","page":"Linear ODEs","title":"Extracting the results, eg. plotting, or projecting","text":"","category":"section"},{"location":"man/linear/#Using-static-arrays-1","page":"Linear ODEs","title":"Using static arrays","text":"","category":"section"},{"location":"man/linear/#Higher-dimensional-ODEs-1","page":"Linear ODEs","title":"Higher-dimensional ODEs","text":"","category":"section"},{"location":"man/linear/#","page":"Linear ODEs","title":"Linear ODEs","text":"combination of state variables to obtain an output","category":"page"},{"location":"man/linear/#Using-lazy-exponentiation-1","page":"Linear ODEs","title":"Using lazy exponentiation","text":"","category":"section"},{"location":"man/nonlinear/#Nonlinear-ordinary-differential-equations-1","page":"Nonlinear ODEs","title":"Nonlinear ordinary differential equations","text":"","category":"section"},{"location":"man/nonlinear/#","page":"Nonlinear ODEs","title":"Nonlinear ODEs","text":"lotka-volterra","category":"page"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"DocTestSetup = :(using ReachabilityAnalysis)\nCurrentModule = ReachabilityAnalysis","category":"page"},{"location":"lib/flowpipes/#Flowpipes-1","page":"Flowpipes","title":"Flowpipes","text":"","category":"section"},{"location":"lib/flowpipes/#Abstract-types-1","page":"Flowpipes","title":"Abstract types","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"AbstractFlowpipe\nAbstractReachSet","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.AbstractFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.AbstractFlowpipe","text":"AbstractFlowpipe\n\nAbstract type representing a flowpipe.\n\nNotes\n\nA flowpipe is the set union of an array of reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#ReachabilityAnalysis.AbstractReachSet","page":"Flowpipes","title":"ReachabilityAnalysis.AbstractReachSet","text":"AbstractReachSet{N}\n\nAbstract type for all reach-sets types.\n\nNotes\n\nA reach-set is a set representation X associated to a given time span Δt.\n\nIn its simplest form, we represent reach-sets with a struct that wraps the tuple (X, Δt), where X corresponds to a geometric set, eg. a polytope, and Δt is the interval with the time span associated to this reach-set.\n\nThis type is parametric in N. The parameter N represents for the type of numerical coefficient used in the representation (typically, N = Float64).\n\nAlthough concrete subtypes of AbstractReachSet may represent the set X in different ways, or carry additional information as an extra type field, they should all implement the AbstractReachSet interface to enable shared functionality for reach-set types. In particular, each concrete subtype should implement the following methods:\n\nset    – return the geometric set\nsetrep – return the type of the set representation\ntspan  – return the time interval span\ntstart – return the initial time\ntend   – return the final time\ndim    – return ambient dimension of the reach-set\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Interface-functions-1","page":"Flowpipes","title":"Interface functions","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"set\nsetrep\ntstart\ntend\ntspan","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.set","page":"Flowpipes","title":"ReachabilityAnalysis.set","text":"set(R::AbstractReachSet)\n\nReturn the geometric set represented by this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe set wrapped by the given reach-set.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#ReachabilityAnalysis.setrep","page":"Flowpipes","title":"ReachabilityAnalysis.setrep","text":"setrep(R::AbstractReachSet)\n\nReturn the type of the set representation of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nType of the set representation of the given reach-set.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tstart","page":"Flowpipes","title":"ReachabilityAnalysis.tstart","text":"tstart(R::AbstractReachSet)\n\nReturn the initial time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the initial time of the given reach-set.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tend","page":"Flowpipes","title":"ReachabilityAnalysis.tend","text":"tend(R::AbstractReachSet)\n\nReturn the final time of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nA float representing the final time of the given reach-set.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#ReachabilityAnalysis.tspan","page":"Flowpipes","title":"ReachabilityAnalysis.tspan","text":"tspan(R::AbstractReachSet)\n\nReturn time span of this reach-set.\n\nInput\n\nR – reach-set\n\nOutput\n\nThe interval representing the time span of the given reach-set.\n\n\n\n\n\n","category":"function"},{"location":"lib/flowpipes/#Reachable-set-1","page":"Flowpipes","title":"Reachable set","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"ReachSet","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.ReachSet","page":"Flowpipes","title":"ReachabilityAnalysis.ReachSet","text":"ReachSet{N, ST<:LazySet{N}} <: AbstractLazyReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation.\n\nFields\n\nX  – set\nΔt – time interval\n\nNotes\n\nA ReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype LazySet. For efficiency reasons, ST should be concretely typed.\n\nBy assumption the coordinates in this reach-set are associated to the integers 1, …, n. The function vars_idx returns such tuple.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Sparse-reachable-set-1","page":"Flowpipes","title":"Sparse reachable set","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"SparseReachSet","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.SparseReachSet","page":"Flowpipes","title":"ReachabilityAnalysis.SparseReachSet","text":"SparseReachSet{N, ST<:LazySet{N}, D} <: AbstractReachSet{N}\n\nType that wraps a reach-set using a LazySet as underlying representation, together with a tuple of variables associated to this reach-set.\n\nFields\n\nX        – set\nΔt       – time interval\nvars_idx – tuple of variable indices represented by the set X\n\nNotes\n\nA SparseReachSet is a struct representing (an approximation of) the reachable states for a given time interval. The type of the representation is ST, which may be any subtype of LazySet (ideally, concrete). Moreover, this type also stores information about the variables (also named coordinates, or by abuse of notation, dimensions) corresponding to the set X.\n\nFor instance in the ambient space n=5, one may have a SparseReachSet whose variables tuple is vars = (4, 5, 6), i.e. representing a three-dimensional projection of the full-dimensional reach-set. In consequence, the dimension of X doesn't match the length of vars, in general\n\nIn this type, the parameter N represents the numerical type of the LazySet (typically, Float64), the type ST represents the set representation used, and D denotes the dimension of this sparse reach set. Note that, in contrast to ReachSet, for SparseReachSet the number of dimensions is part of the type information.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Type-stable-flowpipe-1","page":"Flowpipes","title":"Type-stable flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"Flowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.Flowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.Flowpipe","text":"Flowpipe{N, RT<:AbstractReachSet{N}} <: AbstractFlowpipe\n\nType that wraps a flowpipe.\n\nFields\n\nXk  – set\next – extension dictionary; field used by extensions\n\nNotes\n\nThe dimension of the flowpipe corresponds to the dimension of the underlying reach-sets; in this type, it is is assumed that the dimension is the same for the different reach-sets.\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#Hybrid-flowpipe-1","page":"Flowpipes","title":"Hybrid flowpipe","text":"","category":"section"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"HybridFlowpipe","category":"page"},{"location":"lib/flowpipes/#ReachabilityAnalysis.HybridFlowpipe","page":"Flowpipes","title":"ReachabilityAnalysis.HybridFlowpipe","text":"HybridFlowpipe{N, D, FT<:AbstractFlowpipe, VOA<:VectorOfArray{N, D, Vector{FT}}} <: AbstractFlowpipe\n\nType that wraps a vector of flowpipes of possibly differen types.\n\nFields\n\nFk  – vector of flowpipes\next – (optional, default: empty) dictionary for extensions\n\nNotes\n\n\n\n\n\n","category":"type"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"note: Note\n","category":"page"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"Write some conversion functions from e.g. Abaqus file format.","category":"page"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"for face in 1:nfaces(cell)\n    if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"Neumann Boundary\")\n        reinit!(facevalues, cell, face)\n        for q_point in 1:getnquadpoints(facevalues)\n            dΓ = getdetJdV(facevalues, q_point)\n            for i in 1:getnbasefunctions(facevalues)\n                δu = shape_value(facevalues, q_point, i)\n                fe[i] += δu * b * dΓ\n            end\n        end\n    end\nend","category":"page"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"We start by looping over all the faces of the cell, next we have to check if this particular face is located on the boundary, and then also check that the face is located on our face-set called \"Neumann Boundary\". If we have determined that the current face is indeed on the boundary and in our faceset, then we reinitialize facevalues for this face, using discretize. When reinit!ing facevalues we also need to give the face number in addition to the cell. Next we simply loop over the quadrature points of the face, and then loop over all the test functions and assemble the contribution to the force vector.","category":"page"},{"location":"lib/flowpipes/#","page":"Flowpipes","title":"Flowpipes","text":"note: Examples\nThe following commented examples makes use of Neumann boundary conditions:TODO","category":"page"},{"location":"man/parametric/#Parametric-reachability-1","page":"Parametric reachability","title":"Parametric reachability","text":"","category":"section"},{"location":"man/parametric/#Theory-1","page":"Parametric reachability","title":"Theory","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"Parametric reachability consist of . . . ","category":"page"},{"location":"man/parametric/#Example-1","page":"Parametric reachability","title":"Example","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"We reconsider the example from Section (REF?), but we add an uncertain parameter α that accounts for the variation in the ...","category":"page"},{"location":"man/parametric/#Spring-mass-system-1","page":"Parametric reachability","title":"Spring-mass system","text":"","category":"section"},{"location":"man/parametric/#","page":"Parametric reachability","title":"Parametric reachability","text":"Here we consider variations in the constant k and perform reachability . . . .","category":"page"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"In this section we present two problems related to thermal conduction. The first problem, Heat flow PDE, is a model representing the heat xyz. The second model, Hybrid thermostat model, is","category":"page"},{"location":"man/applications/thermal_conduction/#Heat-flow-PDE-1","page":"-","title":"Heat flow PDE","text":"","category":"section"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"ver uno de los SLICOT benchmarks\nver tambien un paper de Zhi Han","category":"page"},{"location":"man/applications/thermal_conduction/#Hybrid-thermostat-model-1","page":"-","title":"Hybrid thermostat model","text":"","category":"section"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"The system is modeled as a two-mode hybrid automaton.","category":"page"},{"location":"man/applications/thermal_conduction/#","page":"-","title":"-","text":"este ya lo tenemos\nver la referencia","category":"page"},{"location":"man/applications/quadrotor/##-Hyperelasticity-1","page":"Quadrotor altitude control","title":"# Hyperelasticity","text":"","category":"section"},{"location":"man/applications/quadrotor/#-1","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#**Keywords**:-*hyperelasticity*,-*finite-strain*,-*large-deformations*,-*Newton's-method*,-1","page":"Quadrotor altitude control","title":"Keywords: hyperelasticity, finite strain, large deformations, Newton's method,","text":"","category":"section"},{"location":"man/applications/quadrotor/#*conjugate-gradient*,-*automatic-differentiation*-1","page":"Quadrotor altitude control","title":"conjugate gradient, automatic differentiation","text":"","category":"section"},{"location":"man/applications/quadrotor/#-2","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#AGREGAR-IMAGEN-DE-QUADROTOR-AQUI-1","page":"Quadrotor altitude control","title":"AGREGAR IMAGEN DE QUADROTOR AQUI","text":"","category":"section"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"#- #md # AGREGAR EL TIPO DE JUPYTER NOTEBOOK AQUI","category":"page"},{"location":"man/applications/quadrotor/#-3","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#In-this-example-we-will-solve-a-problem-in-a-finite-strain-setting-using-an-1","page":"Quadrotor altitude control","title":"In this example we will solve a problem in a finite strain setting using an","text":"","category":"section"},{"location":"man/applications/quadrotor/#hyperelastic-material-model.-In-order-to-compute-the-stress-we-will-use-automatic-1","page":"Quadrotor altitude control","title":"hyperelastic material model. In order to compute the stress we will use automatic","text":"","category":"section"},{"location":"man/applications/quadrotor/#differentiation,-to-solve-the-non-linear-system-we-use-Newton's-1","page":"Quadrotor altitude control","title":"differentiation, to solve the non-linear system we use Newton's","text":"","category":"section"},{"location":"man/applications/quadrotor/#method,-and-for-solving-the-Newton-increment-we-use-conjugate-gradient.-1","page":"Quadrotor altitude control","title":"method, and for solving the Newton increment we use conjugate gradient.","text":"","category":"section"},{"location":"man/applications/quadrotor/#-4","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#The-weak-format-is-expressed-in-terms-of-the-first-Piola-Kirchoff-stress-\\mathbf{P}-1","page":"Quadrotor altitude control","title":"The weak format is expressed in terms of the first Piola-Kirchoff stress mathbfP","text":"","category":"section"},{"location":"man/applications/quadrotor/#as-follows:-Find-u-\\in-\\mathbb{U}-such-that-1","page":"Quadrotor altitude control","title":"as follows: Find u in mathbbU such that","text":"","category":"section"},{"location":"man/applications/quadrotor/#-5","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#math-1","page":"Quadrotor altitude control","title":"```math","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\int_\\Omega-[\\delta-\\mathbf{u}-\\otimes-\\nabla]-:-\\mathbf{P}(\\mathbf{u})\\-\\mathrm{d}\\Omega-1","page":"Quadrotor altitude control","title":"\\int_\\Omega [\\delta \\mathbf{u} \\otimes \\nabla] : \\mathbf{P}(\\mathbf{u})\\ \\mathrm{d}\\Omega =","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\int*\\Omega-\\delta-\\mathbf{u}-\\cdot-\\mathbf{b}\\-\\mathrm{d}\\Omega-\\int*{\\Gamma\\mathrm{N}}-1","page":"Quadrotor altitude control","title":"\\int\\Omega \\delta \\mathbf{u} \\cdot \\mathbf{b}\\ \\mathrm{d}\\Omega + \\int{\\Gamma^\\mathrm{N}}","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\mathbf{u}-\\cdot-\\mathbf{t}\\-\\mathrm{d}\\Gamma-1","page":"Quadrotor altitude control","title":"\\mathbf{u} \\cdot \\mathbf{t}\\ \\mathrm{d}\\Gamma","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\quad-\\forall-\\delta-\\mathbf{u}-\\in-\\mathbb{U}0,-1","page":"Quadrotor altitude control","title":"\\quad \\forall \\delta \\mathbf{u} \\in \\mathbb{U}^0,","text":"","category":"section"},{"location":"man/applications/quadrotor/#-6","page":"Quadrotor altitude control","title":"```","text":"","category":"section"},{"location":"man/applications/quadrotor/#-7","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#where-\\mathbf{u}-is-the-unknown-displacement-field,-\\mathbf{b}-is-the-body-force,-\\mathbf{t}-1","page":"Quadrotor altitude control","title":"where mathbfu is the unknown displacement field, mathbfb is the body force, mathbft","text":"","category":"section"},{"location":"man/applications/quadrotor/#is-the-traction-on-the-Neumann-part-of-the-boundary,-and-where-\\mathbb{U}-and-\\mathbb{U}0-are-1","page":"Quadrotor altitude control","title":"is the traction on the Neumann part of the boundary, and where mathbbU and mathbbU^0 are","text":"","category":"section"},{"location":"man/applications/quadrotor/#suitable-trial-and-test-sets.-1","page":"Quadrotor altitude control","title":"suitable trial and test sets.","text":"","category":"section"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"using JuAFEM, Tensors, TimerOutputs, ProgressMeter import KrylovMethods, IterativeSolvers","category":"page"},{"location":"man/applications/quadrotor/###-Hyperelastic-material-model-1","page":"Quadrotor altitude control","title":"## Hyperelastic material model","text":"","category":"section"},{"location":"man/applications/quadrotor/#-8","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#The-stress-can-be-derived-from-an-energy-potential,-defined-in-1","page":"Quadrotor altitude control","title":"The stress can be derived from an energy potential, defined in","text":"","category":"section"},{"location":"man/applications/quadrotor/#terms-of-the-right-Cauchy-Green-tensor-\\mathbf{C}.-We-shall-use-a-neo-Hookean-model,-where-1","page":"Quadrotor altitude control","title":"terms of the right Cauchy-Green tensor mathbfC. We shall use a neo-Hookean model, where","text":"","category":"section"},{"location":"man/applications/quadrotor/#the-potential-can-be-written-as-1","page":"Quadrotor altitude control","title":"the potential can be written as","text":"","category":"section"},{"location":"man/applications/quadrotor/#-9","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#math-2","page":"Quadrotor altitude control","title":"```math","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\Psi(\\mathbf{C})-\\frac{\\mu}{2}-(I_C-3)-\\mu-\\ln(J)-\\frac{\\lambda}{2}-\\ln(J)2,-1","page":"Quadrotor altitude control","title":"\\Psi(\\mathbf{C}) = \\frac{\\mu}{2} (I_C - 3) - \\mu \\ln(J) + \\frac{\\lambda}{2} \\ln(J)^2,","text":"","category":"section"},{"location":"man/applications/quadrotor/#-10","page":"Quadrotor altitude control","title":"```","text":"","category":"section"},{"location":"man/applications/quadrotor/#-11","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#where-I_C-\\mathrm{tr}(C),-J-\\sqrt{\\det(C)}-and-\\mu-and-\\lambda-material-parameters.-1","page":"Quadrotor altitude control","title":"where I_C = mathrmtr(C), J = sqrtdet(C) and mu and lambda material parameters.","text":"","category":"section"},{"location":"man/applications/quadrotor/#From-the-potential-we-obtain-the-second-Piola-Kirchoff-stress-\\mathbf{S}-as-1","page":"Quadrotor altitude control","title":"From the potential we obtain the second Piola-Kirchoff stress mathbfS as","text":"","category":"section"},{"location":"man/applications/quadrotor/#-12","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#math-3","page":"Quadrotor altitude control","title":"```math","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\mathbf{S}-2-\\frac{\\partial-\\Psi}{\\partial-\\mathbf{C}},-1","page":"Quadrotor altitude control","title":"\\mathbf{S} = 2 \\frac{\\partial \\Psi}{\\partial \\mathbf{C}},","text":"","category":"section"},{"location":"man/applications/quadrotor/#-13","page":"Quadrotor altitude control","title":"```","text":"","category":"section"},{"location":"man/applications/quadrotor/#-14","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#and-the-tangent-of-\\mathbf{S}-as-1","page":"Quadrotor altitude control","title":"and the tangent of mathbfS as","text":"","category":"section"},{"location":"man/applications/quadrotor/#-15","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#math-4","page":"Quadrotor altitude control","title":"```math","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\frac{\\partial-\\mathbf{S}}{\\partial-\\mathbf{C}}-4-\\frac{\\partial-\\Psi}{\\partial-\\mathbf{C}}.-1","page":"Quadrotor altitude control","title":"\\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{C}} = 4 \\frac{\\partial \\Psi}{\\partial \\mathbf{C}}.","text":"","category":"section"},{"location":"man/applications/quadrotor/#-16","page":"Quadrotor altitude control","title":"```","text":"","category":"section"},{"location":"man/applications/quadrotor/#-17","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#We-can-implement-the-material-model-as-follows,-where-we-utilize-automatic-differentiation-1","page":"Quadrotor altitude control","title":"We can implement the material model as follows, where we utilize automatic differentiation","text":"","category":"section"},{"location":"man/applications/quadrotor/#for-the-stress-and-the-tangent,-and-thus-only-define-the-potential:-1","page":"Quadrotor altitude control","title":"for the stress and the tangent, and thus only define the potential:","text":"","category":"section"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"struct NeoHooke     μ::Float64     λ::Float64 end","category":"page"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"function Ψ(C, mp::NeoHooke)     μ = mp.μ     λ = mp.λ     Ic = tr(C)     J = sqrt(det(C))     return μ / 2 * (Ic - 3) - μ * log(J) + λ / 2 * log(J)^2 end","category":"page"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"function constitutive_driver(C, mp::NeoHooke)     ## Compute all derivatives in one function call     ∂²Ψ∂C², ∂Ψ∂C = Tensors.hessian(y -> Ψ(y, mp), C, :all)     S = 2.0 * ∂Ψ∂C     ∂S∂C = 4.0 * ∂²Ψ∂C²     return S, ∂S∂C end;","category":"page"},{"location":"man/applications/quadrotor/#Finally,-for-the-finite-element-problem-we-need-\\mathbf{P}-and-1","page":"Quadrotor altitude control","title":"Finally, for the finite element problem we need mathbfP and","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\frac{\\partial-\\mathbf{P}}{\\partial-\\mathbf{F}},-which-can-be-obtained-by-the-following-1","page":"Quadrotor altitude control","title":"fracpartial mathbfPpartial mathbfF, which can be obtained by the following","text":"","category":"section"},{"location":"man/applications/quadrotor/#transformations-1","page":"Quadrotor altitude control","title":"transformations","text":"","category":"section"},{"location":"man/applications/quadrotor/#-18","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#math-5","page":"Quadrotor altitude control","title":"```math","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\begin{align*}-1","page":"Quadrotor altitude control","title":"\\begin{align*}","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\mathbf{P}-and-\\mathbf{F}-\\cdot-\\mathbf{S},\\-1","page":"Quadrotor altitude control","title":"\\mathbf{P} &= \\mathbf{F} \\cdot \\mathbf{S},\\","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\frac{\\partial-\\mathbf{P}}{\\partial-\\mathbf{F}}-and-[\\mathbf{F}-\\bar{\\otimes}-\\mathbf{I}]-:-1","page":"Quadrotor altitude control","title":"\\frac{\\partial \\mathbf{P}}{\\partial \\mathbf{F}} &= [\\mathbf{F} \\bar{\\otimes} \\mathbf{I}] :","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\frac{\\partial-\\mathbf{S}}{\\partial-\\mathbf{C}}-:-[\\mathbf{F}\\mathrm{T}-\\bar{\\otimes}-\\mathbf{I}]-1","page":"Quadrotor altitude control","title":"\\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{C}} : [\\mathbf{F}^\\mathrm{T} \\bar{\\otimes} \\mathbf{I}]","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\mathbf{I}-\\bar{\\otimes}-\\mathbf{S}.-1","page":"Quadrotor altitude control","title":"+ \\mathbf{I} \\bar{\\otimes} \\mathbf{S}.","text":"","category":"section"},{"location":"man/applications/quadrotor/#\\end{align*}-1","page":"Quadrotor altitude control","title":"\\end{align*}","text":"","category":"section"},{"location":"man/applications/quadrotor/#-19","page":"Quadrotor altitude control","title":"```","text":"","category":"section"},{"location":"man/applications/quadrotor/#-20","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/###-Finite-element-assembly-1","page":"Quadrotor altitude control","title":"## Finite element assembly","text":"","category":"section"},{"location":"man/applications/quadrotor/#-21","page":"Quadrotor altitude control","title":"","text":"","category":"section"},{"location":"man/applications/quadrotor/#The-element-routine-for-assembling-the-residual-and-tangent-stiffness-is-implemented-1","page":"Quadrotor altitude control","title":"The element routine for assembling the residual and tangent stiffness is implemented","text":"","category":"section"},{"location":"man/applications/quadrotor/#as-usual,-with-loops-over-quadrature-points-and-shape-functions:-1","page":"Quadrotor altitude control","title":"as usual, with loops over quadrature points and shape functions:","text":"","category":"section"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"function assemble_element!(ke, ge, cell, cv, fv, mp, ue)     ## Reinitialize cell values, and reset output arrays     reinit!(cv, cell)     fill!(ke, 0.0)     fill!(ge, 0.0)","category":"page"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"b = Vec{3}((0.0, -0.5, 0.0)) # Body force\nt = Vec{3}((0.1, 0.0, 0.0)) # Traction\nndofs = getnbasefunctions(cv)\n\nfor qp in 1:getnquadpoints(cv)\n    dΩ = getdetJdV(cv, qp)\n    ## Compute deformation gradient F and right Cauchy-Green tensor C\n    ∇u = function_gradient(cv, qp, ue)\n    F = one(∇u) + ∇u\n    C = tdot(F)\n    ## Compute stress and tangent\n    S, ∂S∂C = constitutive_driver(C, mp)\n    P = F ⋅ S\n    I = one(S)\n    ∂P∂F = otimesu(F, I) ⊡ ∂S∂C ⊡ otimesu(F', I) + otimesu(I, S)\n\n    ## Loop over test functions\n    for i in 1:ndofs\n        ## Test function + gradient\n        δui = shape_value(cv, qp, i)\n        ∇δui = shape_gradient(cv, qp, i)\n        ## Add contribution to the residual from this test function\n        ge[i] += ( ∇δui ⊡ P - δui ⋅ b ) * dΩ\n\n        ∇δui∂P∂F = ∇δui ⊡ ∂P∂F # Hoisted computation\n        for j in 1:ndofs\n            ∇δuj = shape_gradient(cv, qp, j)\n            ## Add contribution to the tangent\n            ke[i, j] += ( ∇δui∂P∂F ⊡ ∇δuj ) * dΩ\n        end\n    end\nend\n\n## Surface integral for the traction\nfor face in 1:nfaces(cell)\n    if onboundary(cell, face)\n        reinit!(fv, cell, face)\n        for q_point in 1:getnquadpoints(fv)\n            dΓ = getdetJdV(fv, q_point)\n            for i in 1:ndofs\n                δui = shape_value(fv, q_point, i)\n                ge[i] -= (δui ⋅ t) * dΓ\n            end\n        end\n    end\nend","category":"page"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"end;","category":"page"},{"location":"man/applications/quadrotor/#Assembling-global-residual-and-tangent-1","page":"Quadrotor altitude control","title":"Assembling global residual and tangent","text":"","category":"section"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"function assembleglobal!(K, f, dh, cv, fv, mp, u)     n = ndofsper_cell(dh)     ke = zeros(n, n)     ge = zeros(n)","category":"page"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"## start_assemble resets K and f\nassembler = start_assemble(K, f)\n\n## Loop over all cells in the grid\n@timeit \"assemble\" for cell in CellIterator(dh)\n    global_dofs = celldofs(cell)\n    ue = u[global_dofs] # element dofs\n    @timeit \"element assemble\" assemble_element!(ke, ge, cell, cv, fv, mp, ue)\n    assemble!(assembler, global_dofs, ge, ke)\nend","category":"page"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"end;","category":"page"},{"location":"man/applications/quadrotor/#Define-a-main-function,-with-a-loop-for-Newton-iterations-1","page":"Quadrotor altitude control","title":"Define a main function, with a loop for Newton iterations","text":"","category":"section"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"function solve()     reset_timer!()","category":"page"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"## Generate a grid\nN = 10\nL = 1.0\nleft = zero(Vec{3})\nright = L * ones(Vec{3})\ngrid = generate_grid(Tetrahedron, (N, N, N), left, right)\n\n## Material parameters\nE = 10.0\nν = 0.3\nμ = E / (2(1 + ν))\nλ = (E * ν) / ((1 + ν) * (1 - 2ν))\nmp = NeoHooke(μ, λ)\n\n## Finite element base\nip = Lagrange{3, RefTetrahedron, 1}()\nqr = QuadratureRule{3, RefTetrahedron}(1)\nqr_face = QuadratureRule{2, RefTetrahedron}(1)\ncv = CellVectorValues(qr, ip)\nfv = FaceVectorValues(qr_face, ip)\n\n## DofHandler\ndh = DofHandler(grid)\npush!(dh, :u, 3) # Add a displacement field\nclose!(dh)\n\nfunction rotation(X, t, θ = deg2rad(60.0))\n    x, y, z = X\n    return t * Vec{3}(\n        (0.0,\n        L/2 - y + (y-L/2)*cos(θ) - (z-L/2)*sin(θ),\n        L/2 - z + (y-L/2)*sin(θ) + (z-L/2)*cos(θ)\n        ))\nend\n\ndbcs = ConstraintHandler(dh)\n## Add a homogenous boundary condition on the \"clamped\" edge\ndbc = Dirichlet(:u, getfaceset(grid, \"right\"), (x,t) -> [0.0, 0.0, 0.0], [1, 2, 3])\nadd!(dbcs, dbc)\ndbc = Dirichlet(:u, getfaceset(grid, \"left\"), (x,t) -> rotation(x, t), [1, 2, 3])\nadd!(dbcs, dbc)\nclose!(dbcs)\nt = 0.5\nJuAFEM.update!(dbcs, t)\n\n## Pre-allocation of vectors for the solution and Newton increments\n_ndofs = ndofs(dh)\nun = zeros(_ndofs) # previous solution vector\nu  = zeros(_ndofs)\nΔu = zeros(_ndofs)\nΔΔu = zeros(_ndofs)\napply!(un, dbcs)\n\n## Create sparse matrix and residual vector\nK = create_sparsity_pattern(dh)\ng = zeros(_ndofs)\n\n\n## Perform Newton iterations\nnewton_itr = -1\nNEWTON_TOL = 1e-8\nprog = ProgressMeter.ProgressThresh(NEWTON_TOL, \"Solving:\")\n\nwhile true; newton_itr += 1\n    u .= un .+ Δu # Current guess\n    assemble_global!(K, g, dh, cv, fv, mp, u)\n    normg = norm(g[JuAFEM.free_dofs(dbcs)])\n    apply_zero!(K, g, dbcs)\n    ProgressMeter.update!(prog, normg; showvalues = [(:iter, newton_itr)])\n\n    if normg < NEWTON_TOL\n        break\n    elseif newton_itr > 30\n        error(\"Reached maximum Newton iterations, aborting\")\n    end\n\n    ## Compute increment using cg! from IterativeSolvers.jl\n    @timeit \"linear solve (KrylovMethods.cg)\" ΔΔu′, flag, relres, iter, resvec = KrylovMethods.cg(K, g; maxIter = 1000)\n    @assert flag == 0\n    @timeit \"linear solve (IterativeSolvers.cg!)\" IterativeSolvers.cg!(ΔΔu, K, g; maxiter=1000)\n\n    apply_zero!(ΔΔu, dbcs)\n    Δu .-= ΔΔu\nend\n\n## Save the solution\n@timeit \"export\" begin\n    vtk_grid(\"hyperelasticity\", dh) do vtkfile\n        vtk_point_data(vtkfile, dh, u)\n    end\nend\n\nprint_timer(title = \"Analysis with $(getncells(grid)) elements\", linechars = :ascii)\nreturn u","category":"page"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"end","category":"page"},{"location":"man/applications/quadrotor/#Run-the-simulation-1","page":"Quadrotor altitude control","title":"Run the simulation","text":"","category":"section"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"u = solve();","category":"page"},{"location":"man/applications/quadrotor/#test-the-result-#src-1","page":"Quadrotor altitude control","title":"test the result                #src","text":"","category":"section"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"using Test                        #src @test norm(u) ≈ 4.865189736192834 #src","category":"page"},{"location":"man/applications/quadrotor/#","page":"Quadrotor altitude control","title":"Quadrotor altitude control","text":"#md # ## Plain Program #md # #md # Below follows a version of the program without any comments. #md # The file is also available here: .... #md # #md # julia #md # @__CODE__ #md #","category":"page"},{"location":"introduction/#Installing-1","page":"Introduction","title":"Installing","text":"","category":"section"},{"location":"introduction/#[Install-the-latest-release-version](https://julialang.github.io/Pkg.jl/v1/managing-packages/#Adding-registered-packages-1)-(recommended-for-first-time-use)-1","page":"Introduction","title":"Install the latest release version (recommended for first-time use)","text":"","category":"section"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"pkg> add ReachabilityAnalysis.jl","category":"page"},{"location":"introduction/#Install-the-latest-development-version-1","page":"Introduction","title":"Install the latest development version","text":"","category":"section"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"pkg> add https://github.com/mforets/ReachabilityAnalysis.jl#master","category":"page"},{"location":"introduction/#[Clone-the-package-for-development](https://julialang.github.io/Pkg.jl/v1/managing-packages/#Developing-packages-1)-1","page":"Introduction","title":"Clone the package for development","text":"","category":"section"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"pkg> dev https://github.com/mforets/ReachabilityAnalysis.jl","category":"page"},{"location":"man/hybrid/#Hybrid-differential-equations-1","page":"Hybrid systems","title":"Hybrid differential equations","text":"","category":"section"},{"location":"man/hybrid/#","page":"Hybrid systems","title":"Hybrid systems","text":"bouncing ball","category":"page"},{"location":"man/setrep/#Set-representations-1","page":"Set representations","title":"Set representations","text":"","category":"section"},{"location":"man/setrep/#Reach-sets-1","page":"Set representations","title":"Reach-sets","text":"","category":"section"},{"location":"man/setrep/#Flowpipes-1","page":"Set representations","title":"Flowpipes","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#BFFPSV18-1","page":"BFFPSV18","title":"BFFPSV18","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#Reachable-states-approximation-1","page":"BFFPSV18","title":"Reachable states approximation","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"In a nutshell, we overapproximate the reachable states of an affine system by solving a set-based recurrence. The key idea is that we first decompose the system into (low-dimensional) subsystems and later compose the results as a Cartesian product. Thus we have to solve many cheap problems instead of one hard problem. Since solving the recurrence scales superlinearly with the dimension, this approach is very scalable.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Decomposition-error-1","page":"BFFPSV18","title":"Decomposition error","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"Decomposition typically involves a loss in precision, and so does this approach. The good thing is that we can decompose the recurrence as well, which allows us to analyze each of the subsystems independently by only referring to the initial states of the other subsystems. Consequently, there are two main sources for precision loss:","category":"page"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"Decomposition of the initial states: If two subsystems are interdependent initially.\nRepresentation of the reachable states as a Cartesian product: If two subsystems are interdependent in the dynamics.\nRepresentation of the reachable states in general: The reachable states of affine systems cannot be represented precisely in all cases. This is a problem that all approaches suffer from. We overapproximate the reachable states by (unions of) convex polytopes.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Checking-safety-properties-1","page":"BFFPSV18","title":"Checking safety properties","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"The problem of checking a safety property can be reduced to a reachability problem. We provide special support for this reduction by inlining the property check into the reachable states computation. This has two benefits:","category":"page"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"We fail fast when the property is violated in our abstraction.\nThe check is usually cheaper than computing the full reachable states. This is because we are often only interested in an upper or lower bound of a variable.","category":"page"},{"location":"lib/algorithms/BFFPSV18/#Lazy-sets-1","page":"BFFPSV18","title":"Lazy sets","text":"","category":"section"},{"location":"lib/algorithms/BFFPSV18/#","page":"BFFPSV18","title":"BFFPSV18","text":"To represent sets of states, we use the LazySets package which provides exact but lazy (i.e. symbolic) representations of common sets.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"DocTestSetup = :(using ReachabilityAnalysis)","category":"page"},{"location":"#ReachabilityAnalysis.jl-1","page":"Home","title":"ReachabilityAnalysis.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ReachabilityAnalysis.jl is a library to compute rigorous approximations of the sets of states reachable by dynamical systems.  The library can handle ordinary differential equations (ODEs) with uncertain initial states, parameters or inputs.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To illustrate, here formulate the forward-time reachability problem for a In the technical literature, this problem is called reachability analysis or validated integration.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"X = left x  int_0^t f(x p t u) dt right","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In the literature, the set X is called a flowpipe.","category":"page"},{"location":"#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The following types of ODEs are currently supported:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Continuous ODEs with linear dynamics\nContinuous ODEs with non-linear dynamics\nHybrid systems with piecweise-affine dynamics\nHybrid systems with non-linear dynamics","category":"page"},{"location":"#","page":"Home","title":"Home","text":"warning: Warning\nThis package is still a work-in-progress and it has grown out of JuliaReach/Reachability.jl. If you are interested to know more about the project, if you found a bug, or if you want to propose an idea for improvement, feel free to open an issue or join the chat room JuliaReach gitter channel.","category":"page"},{"location":"#Application-domains-1","page":"Home","title":"Application domains","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ReachabilityAnalysis is a Julia package for approximating the reachable states and checking safety properties of affine systems.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Reachability analysis has applications in diverse domains such as:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"verification of deep neural networks\nalgorithmic verification\nxxx\nyyy\nzzz","category":"page"},{"location":"#Benchmarks-1","page":"Home","title":"Benchmarks","text":"","category":"section"},{"location":"#Roadmap-1","page":"Home","title":"Roadmap","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"DocTestSetup = :(using ReachabilityAnalysis)","category":"page"},{"location":"lib/discretize/#Discretization-1","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"Pages = [\"discretize.md\"]\nDepth = 3","category":"page"},{"location":"lib/discretize/#Linear-systems-1","page":"Discretization","title":"Linear systems","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"ReachabilityAnalysis.discretize\nReachabilityAnalysis.discretize_interpolation\nReachabilityAnalysis.discretize_firstorder\nReachabilityAnalysis.discretize_nobloating\nReachabilityAnalysis.discretize_interval_matrix","category":"page"},{"location":"lib/discretize/#Exponentiation-1","page":"Discretization","title":"Exponentiation","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"Let A  mathbbR^nn and for t  0 consider the integral int_0^t e^Aξdξ. If A is invertible, this integral","category":"page"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"ReachabilityAnalysis.exp_Aδ\nReachabilityAnalysis.Φ₁\nReachabilityAnalysis.Φ₂","category":"page"},{"location":"lib/discretize/#ReachabilityAnalysis.Φ₁","page":"Discretization","title":"ReachabilityAnalysis.Φ₁","text":"Φ₁(A, δ, method)\n\nCompute the series\n\nΦ₁(A δ) = _i=0^ dfracδ^i+1(i+1)A^i\n\nwhere A is a square matrix of order n and δ  mathbbR_0.\n\nInput\n\nA           – coefficient matrix\nδ           – step size\nmethod  – (optional, default: \"base\") the method used to take the matrix                   exponential of the coefficient matrix; see the documentation of                   exp_Aδ for available options\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nWe use the method from [1]. If A is invertible, Φ₁ can be computed as\n\nΦ₁(A δ) = A^-1(e^δA - I_n)\n\nwhere I_n is the identity matrix of order n.\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP = exp beginpmatrix\nAδ  δI_n  0 \n0  0      δI_n \n0  0      0\nendpmatrix\n\nIt can be shown that Φ₁(A, δ) = P[1:n, (n+1):2*n].\n\n[1] Frehse, Goran, et al. \"SpaceEx: Scalable verification of hybrid systems.\" International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2011.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#ReachabilityAnalysis.Φ₂","page":"Discretization","title":"ReachabilityAnalysis.Φ₂","text":"Φ₂(A, δ, method)\n\nCompute the series\n\nΦ₂(A δ) = _i=0^ dfracδ^i+2(i+2)A^i\n\nwhere A is a square matrix of order n and δ  mathbbR_0.\n\nInput\n\nA           – coefficient matrix\nδ           – step size\nmethod       – the method used to take the matrix                   exponential of the coefficient matrix; see the documentation of                   exp_Aδ for available options\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nWe use the method from [1]. If A is invertible, Φ₂ can be computed as\n\nΦ₂(A δ) = A^-2(e^δA - I_n - δA)\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP = exp beginpmatrix\nAδ  δI_n  0 \n0  0  δI_n \n0  0  0\nendpmatrix\n\nIt can be shown that Φ₂(A, δ) = P[1:n, (2*n+1):3*n].\n\n[1] Frehse, Goran, et al. \"SpaceEx: Scalable verification of hybrid systems.\" International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2011.\n\n\n\n\n\n","category":"function"}]
}
